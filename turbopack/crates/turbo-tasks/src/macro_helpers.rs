//! Runtime helpers for [turbo-tasks-macro].

use std::any::TypeId;

pub use async_trait::async_trait;
pub use bincode;
pub use once_cell::sync::{Lazy, OnceCell};
use rustc_hash::FxHashMap;
pub use shrink_to_fit;
pub use tracing;

use crate::{
    FxDashMap, NonLocalValue, RawVc, TaskInput, TaskPersistence, TraitTypeId, ValueType,
    ValueTypeId, debug::ValueDebugFormatString,
};
pub use crate::{
    global_name_for_method, global_name_for_scope, global_name_for_trait_method,
    global_name_for_trait_method_impl, global_name_for_type, inventory_submit,
    magic_any::MagicAny,
    manager::{find_cell_by_id, find_cell_by_type, spawn_detached_for_testing},
    native_function::{
        CollectableFunction, NativeFunction, downcast_args_owned, downcast_args_ref,
    },
    value_type::{CollectableTrait, CollectableValueType},
};

#[inline(never)]
pub async fn value_debug_format_field(value: ValueDebugFormatString<'_>) -> String {
    match value.try_to_value_debug_string().await {
        Ok(result) => match result.await {
            Ok(result) => result.to_string(),
            Err(err) => format!("{err:?}"),
        },
        Err(err) => format!("{err:?}"),
    }
}

pub fn get_persistence_from_inputs(inputs: &impl TaskInput) -> TaskPersistence {
    if inputs.is_transient() {
        TaskPersistence::Transient
    } else {
        TaskPersistence::Persistent
    }
}

pub fn get_persistence_from_inputs_and_this(
    this: RawVc,
    inputs: &impl TaskInput,
) -> TaskPersistence {
    if this.is_transient() || inputs.is_transient() {
        TaskPersistence::Transient
    } else {
        TaskPersistence::Persistent
    }
}

pub fn assert_argument_is_non_local_value<Argument: NonLocalValue>() {}

#[macro_export]
macro_rules! stringify_path {
    ($path:path) => {
        stringify!($path)
    };
}

/// Rexport std::ptr::metadata so not every crate needs to enable the feature when they use our
/// macros.
#[inline(always)]
pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as std::ptr::Pointee>::Metadata {
    // Ideally we would just `pub use std::ptr::metadata;` but this doesn't seem to work.
    std::ptr::metadata(ptr)
}

/// A registry of all the impl vtables for a given VcValue trait
/// This is constructed in the macro gencode and populated by the registry.
#[derive(Default)]
pub struct VTableRegistry<T: ?Sized> {
    map: FxHashMap<ValueTypeId, <T as std::ptr::Pointee>::Metadata>,
}

impl<T: ?Sized> VTableRegistry<T> {
    pub fn new(id: TraitTypeId) -> Self {
        let mut map = FxHashMap::default();
        match TRAIT_CAST_FNS.remove(&id) {
            Some((_, impls)) => {
                for (value_type_id, RawPtr(raw_fn)) in impls {
                    // SAFETY: These are generated by the macro gencode in value_impl with this
                    // signature.
                    let cast_fn: fn(*const ()) -> *const T = unsafe { std::mem::transmute(raw_fn) };
                    // Cast a null pointer to a fat pointer using the cast_fn, this allows us to
                    // capture a vtable Alternatively we could just store the
                    // cast functions but it will be faster to call 'from_raw_parts' instead of an
                    // indirect function call.
                    let ptr = cast_fn(std::ptr::null::<()>());
                    let metadata = std::ptr::metadata(ptr);
                    let prev = map.insert(value_type_id, metadata);
                    debug_assert!(
                        prev.is_none(),
                        "multiple cast functions registered for {value_type_id}"
                    )
                }
            }
            None => {
                // A trait doesn't have to have any implementations.
            }
        }

        Self { map }
    }

    pub(crate) fn cast(&self, id: ValueTypeId, raw: *const ()) -> *const T {
        let metadata = self.map.get(&id).unwrap();
        std::ptr::from_raw_parts(raw, *metadata)
    }
}

struct RawPtr(*const ());
// SAFETY: We only store function pointers in here which are safe to send/sync
unsafe impl Sync for RawPtr {}
unsafe impl Send for RawPtr {}

// Accumulate all trait impls by trait id
static TRAIT_CAST_FNS: Lazy<FxDashMap<TraitTypeId, Vec<(ValueTypeId, RawPtr)>>> = Lazy::new(|| {
    let map: FxDashMap<TraitTypeId, Vec<(ValueTypeId, RawPtr)>> = FxDashMap::default();
    for CollectableTraitCastFunctions(trait_id_fn, value_id_fn, cast_fn) in
        inventory::iter::<CollectableTraitCastFunctions>
    {
        map.entry(trait_id_fn())
            .or_default()
            .value_mut()
            .push((value_id_fn(), RawPtr(*cast_fn)));
    }
    map
});

// Holds a raw pointer to a function that can perform a fat pointer cast
pub struct CollectableTraitCastFunctions(
    pub fn() -> TraitTypeId,
    pub fn() -> ValueTypeId,
    pub *const (),
);
// SAFETY: We only store function pointers in here.
unsafe impl Sync for CollectableTraitCastFunctions {}
inventory::collect! {CollectableTraitCastFunctions}

#[allow(clippy::type_complexity)]
pub struct CollectableTraitMethods(
    pub  fn() -> (
        TypeId,
        TraitTypeId,
        Vec<(&'static str, &'static NativeFunction)>,
    ),
);
inventory::collect!(CollectableTraitMethods);

// Called when initializing ValueTypes by value_impl
pub fn register_trait_methods(type_id: TypeId, value_type: &mut ValueType) {
    #[allow(clippy::type_complexity)]
    static TRAIT_METHODS_BY_VALUE: Lazy<
        FxDashMap<TypeId, Vec<(TraitTypeId, Vec<(&'static str, &'static NativeFunction)>)>>,
    > = Lazy::new(|| {
        let map: FxDashMap<TypeId, Vec<_>> = FxDashMap::default();
        for CollectableTraitMethods(thunk) in inventory::iter::<CollectableTraitMethods> {
            let (type_id, trait_type_id, fn_items) = thunk();
            map.entry(type_id)
                .or_default()
                .push((trait_type_id, fn_items));
        }
        map
    });
    match TRAIT_METHODS_BY_VALUE.remove(&type_id) {
        Some((_, traits)) => {
            for (trait_type_id, methods) in traits {
                let trait_type = crate::registry::get_trait(trait_type_id);
                value_type.register_trait(trait_type_id);
                for (name, method) in methods {
                    value_type.register_trait_method(trait_type.get(name), method);
                }
            }
        }
        None => {
            // do nothing, values don't have to implement any traits
        }
    }
}

/// Submit an item to the inventory.
///
/// This macro is a wrapper around `inventory::submit` that adds a `#[not(cfg(rust_analyzer))]`
/// attribute to the item. This is to avoid warnings about unused items when using Rust Analyzer.
#[doc(hidden)]
#[macro_export]
macro_rules! inventory_submit {
    ($($item:tt)*) => {
        #[cfg(not(rust_analyzer))]
        $crate::macro_helpers::inventory_submit_inner! { $($item)* }
    }
}

/// Exported so the above macro can reference it.
#[doc(hidden)]
pub use inventory::submit as inventory_submit_inner;

#[doc(hidden)]
#[macro_export]
macro_rules! debug_assert_runs_once {
    () => {
        #[cfg(debug_assertions)]
        {
            use ::std::sync::atomic::{AtomicBool, Ordering};
            static ONLY_RUN_ONCE: AtomicBool = AtomicBool::new(false);
            assert!(!AtomicBool::swap(&ONLY_RUN_ONCE, true, Ordering::AcqRel));
        }
    };
}

/// Use `type_name` to get globally unique identifier that's stable across multiple executions of
/// the same Turbopack version, potentially allowing cache sharing across platforms/architectures.
///
/// The stdlib docs explicitly recommend against using type_name to get a unique identifier, but the
/// way we're using it here seems unlikely to break. We've got runtime logic to panic if it breaks.
#[doc(hidden)]
#[macro_export]
macro_rules! global_name_for_type {
    ($item:ty) => {
        ::std::any::type_name::<$item>()
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! global_name_for_method {
    ($ty:ty, $method:ident) => {{
        // We cannot use `concat!` because `type_name` is not const, so we leak the string instead
        // to get a &'static str.
        //
        // Assumption: the code that invokes this macro is only run once (e.g. part of an
        // `inventory::submit!` callsite), so we're leaking a bounded number of strings.
        $crate::debug_assert_runs_once!();
        ::std::boxed::Box::leak(::std::string::String::into_boxed_str(::std::format!(
            "{}::{}",
            ::std::any::type_name::<$ty>(),
            ::std::stringify!($method),
        )))
    }};
}

#[doc(hidden)]
#[macro_export]
macro_rules! global_name_for_trait_method {
    ($trait:path, $method:ident) => {{
        $crate::debug_assert_runs_once!();
        ::std::boxed::Box::leak(::std::string::String::into_boxed_str(::std::format!(
            "<{}>::{}",
            ::std::any::type_name::<dyn $trait>(),
            ::std::stringify!($method),
        )))
    }};
}

#[doc(hidden)]
#[macro_export]
macro_rules! global_name_for_trait_method_impl {
    ($ty:ty, $trait:path, $method:ident) => {{
        $crate::debug_assert_runs_once!();
        ::std::boxed::Box::leak(::std::string::String::into_boxed_str(::std::format!(
            "<{} as {}>::{}",
            ::std::any::type_name::<$ty>(),
            ::std::any::type_name::<dyn $trait>(),
            ::std::stringify!($method),
        )))
    }};
}

/// Get a globally unique name for an identifier a current or parent scope.
#[doc(hidden)]
#[macro_export]
macro_rules! global_name_for_scope {
    ($depth:literal, $($item:tt)+) => {{
        $crate::debug_assert_runs_once!();

        struct PlaceholderMarkerType;
        let mut base = ::std::any::type_name::<PlaceholderMarkerType>();

        // strip a caller-defined number of ancestors from the end of the path
        for _ in 0..($depth+1) {  // add one to `depth` for the placeholder
            base = ::std::option::Option::unwrap(
                ::std::primitive::str::rsplit_once(base, "::"),
            ).0;
        }

        ::std::boxed::Box::leak(
            ::std::string::String::into_boxed_str(
                ::std::format!("{}::{}", base, ::std::stringify!($($item)+))
            ),
        )
    }}
}
