{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n/**\n * Describes why a module was instantiated.\n * Shared between browser and Node.js runtimes.\n */\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\n// @ts-ignore Defined in `hmr-runtime.ts` (dev mode only)\ndeclare let devModuleCache: Record<ModuleId, any> | undefined\n\n/**\n * Flag indicating which module object type to create when a module is merged. Set to `true`\n * by each runtime that uses ModuleWithDirection (browser dev-base.ts, nodejs dev-base.ts,\n * nodejs build-base.ts). Browser production (build-base.ts) leaves it as `false` since it\n * uses plain Module objects.\n */\nlet createModuleWithDirectionFlag = false\n\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(\n  this: TurbopackBaseContext<Module>,\n  module: Module,\n  exports: Exports\n) {\n  this.m = module\n  // We need to store this here instead of accessing it from the module object to:\n  // 1. Make it available to factories directly, since we rewrite `this` to\n  //    `__turbopack_context__.e` in CJS modules.\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\n  //    can still access the original exports object from functions like\n  //    `esmExport`\n  // Ideally we could find a new approach for async modules and drop this property altogether.\n  this.e = exports\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: string): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: string): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\n  moduleId: M['id'],\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId\n): Module {\n  let module = moduleCache[id]\n  if (!module) {\n    if (createModuleWithDirectionFlag) {\n      // set in development modes for hmr support\n      module = createModuleWithDirection(id)\n    } else {\n      module = createModuleObject(id)\n    }\n    moduleCache[id] = module\n  }\n  return module\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n  }\n}\n\nfunction createModuleWithDirection(id: ModuleId): ModuleWithDirection {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n    parents: [],\n    children: [],\n  }\n}\n\ntype BindingTag = 0\nconst BindingTag_Value = 0 as BindingTag\n\n// an arbitrary sequence of bindings as\n// - a prop name\n// - BindingTag_Value, a value to be bound directly, or\n// - 1 or 2 functions to bind as getters and sdetters\ntype EsmBindings = Array<\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\n>\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, bindings: EsmBindings) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  let i = 0\n  while (i < bindings.length) {\n    const propName = bindings[i++] as string\n    const tagOrFunction = bindings[i++]\n    if (typeof tagOrFunction === 'number') {\n      if (tagOrFunction === BindingTag_Value) {\n        defineProp(exports, propName, {\n          value: bindings[i++],\n          enumerable: true,\n          writable: false,\n        })\n      } else {\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\n      }\n    } else {\n      const getterFn = tagOrFunction as () => unknown\n      if (typeof bindings[i] === 'function') {\n        const setterFn = bindings[i++] as (v: unknown) => void\n        defineProp(exports, propName, {\n          get: getterFn,\n          set: setterFn,\n          enumerable: true,\n        })\n      } else {\n        defineProp(exports, propName, {\n          get: getterFn,\n          enumerable: true,\n        })\n      }\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  bindings: EsmBindings,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Module['exports']\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  module.namespaceObject = exports\n  esm(exports, bindings)\n}\ncontextPrototype.s = esmExport\n\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\nfunction ensureDynamicExports(\n  module: Module,\n  exports: Exports\n): ReexportedObjects {\n  let reexportedObjects: ReexportedObjects | undefined =\n    REEXPORTED_OBJECTS.get(module)\n\n  if (!reexportedObjects) {\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n  return reexportedObjects\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Exports\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  const reexportedObjects = ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    reexportedObjects.push(object)\n  }\n}\ncontextPrototype.j = dynamicExport\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = value\n}\ncontextPrototype.v = exportValue\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = module.namespaceObject = namespace\n}\ncontextPrototype.n = exportNamespace\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const bindings: EsmBindings = []\n  let defaultLocation = -1\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      bindings.push(key, createGetter(raw, key))\n      if (defaultLocation === -1 && key === 'default') {\n        defaultLocation = bindings.length - 1\n      }\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && defaultLocation >= 0)) {\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\n    if (defaultLocation >= 0) {\n      // Replace the getter with the value\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\n    } else {\n      bindings.push('default', BindingTag_Value, raw)\n    }\n  }\n\n  esm(ns, bindings)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m)\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\ncontextPrototype.i = esmImport\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport\n  ) => Promise<Exports>\n  return loader(esmImport.bind(this))\n}\ncontextPrototype.A = asyncLoader\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\ncontextPrototype.t = runtimeRequire\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exports {\n  return getOrInstantiateModuleFromParent(id, this.m).exports\n}\ncontextPrototype.r = commonJsRequire\n\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */\nfunction parseRequest(request: string): string {\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n  const hashIndex = request.indexOf('#')\n  if (hashIndex !== -1) {\n    request = request.substring(0, hashIndex)\n  }\n\n  const queryIndex = request.indexOf('?')\n  if (queryIndex !== -1) {\n    request = request.substring(0, queryIndex)\n  }\n\n  return request\n}\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: string): Exports {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): string[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: string): ModuleId => {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: string) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\ncontextPrototype.f = moduleContext\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(\n  chunkModules: CompressedModuleFactories,\n  offset: number,\n  moduleFactories: ModuleFactories,\n  newModuleId?: (id: ModuleId) => void\n) {\n  let i = offset\n  while (i < chunkModules.length) {\n    let end = i + 1\n    // Find our factory function\n    while (\n      end < chunkModules.length &&\n      typeof chunkModules[end] !== 'function'\n    ) {\n      end++\n    }\n    if (end === chunkModules.length) {\n      throw new Error('malformed chunk format, expected a factory function')\n    }\n\n    // Install the factory for each module ID that doesn't already have one.\n    // When some IDs in this group already have a factory, reuse that existing\n    // group factory for the missing IDs to keep all IDs in the group consistent.\n    // Otherwise, install the factory from this chunk.\n    const moduleFactoryFn = chunkModules[end] as Function\n    let existingGroupFactory: Function | undefined = undefined\n    for (let j = i; j < end; j++) {\n      const id = chunkModules[j] as ModuleId\n      const existingFactory = moduleFactories.get(id)\n      if (existingFactory) {\n        existingGroupFactory = existingFactory\n        break\n      }\n    }\n    const factoryToInstall = existingGroupFactory ?? moduleFactoryFn\n\n    let didInstallFactory = false\n    for (let j = i; j < end; j++) {\n      const id = chunkModules[j] as ModuleId\n      if (!moduleFactories.has(id)) {\n        if (!didInstallFactory) {\n          if (factoryToInstall === moduleFactoryFn) {\n            applyModuleFactoryName(moduleFactoryFn)\n          }\n          didInstallFactory = true\n        }\n        moduleFactories.set(id, factoryToInstall)\n        newModuleId?.(id)\n      }\n    }\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const module = this.m\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\ncontextPrototype.a = asyncModule\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\nrelativeURL.prototype = URL.prototype\ncontextPrototype.U = relativeURL\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * Constructs an error message for when a module factory is not available.\n */\nfunction factoryNotAvailableMessage(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): string {\n  let instantiationReason: string\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\n      break\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`\n      break\n    case SourceType.Update:\n      instantiationReason = 'because of an HMR update'\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\ncontextPrototype.z = requireStub\n\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis\n\ntype ContextConstructor<M> = {\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\n}\n\nfunction applyModuleFactoryName(factory: Function) {\n  // Give the module factory a nice name to improve stack traces.\n  Object.defineProperty(factory, 'name', {\n    value: 'module evaluation',\n  })\n}\n"],"names":["SourceType","createModuleWithDirectionFlag","REEXPORTED_OBJECTS","WeakMap","Context","module","exports","m","e","contextPrototype","prototype","hasOwnProperty","Object","toStringTag","Symbol","defineProp","obj","name","options","call","defineProperty","getOverwrittenModule","moduleCache","id","createModuleWithDirection","createModuleObject","error","undefined","namespaceObject","parents","children","BindingTag_Value","esm","bindings","value","i","length","propName","tagOrFunction","enumerable","writable","Error","getterFn","setterFn","get","set","seal","esmExport","c","s","ensureDynamicExports","reexportedObjects","Proxy","target","prop","Reflect","_iteratorError","ownKeys","keys","_iteratorError1","key","includes","push","dynamicExport","object","_type_of","j","exportValue","v","exportNamespace","namespace","n","createGetter","getProto","getPrototypeOf","__proto__","LEAF_PROTOTYPES","interopEsm","raw","ns","allowExportDefault","defaultLocation","current","getOwnPropertyNames","splice","createNS","_key","args","apply","create","esmImport","getOrInstantiateModuleFromParent","__esModule","asyncLoader","moduleId","loader","r","bind","A","runtimeRequire","require","require1","t","commonJsRequire","parseRequest","request","hashIndex","indexOf","substring","queryIndex","moduleContext","map","code","resolve","import","f","getChunkPath","chunkData","path","isPromise","maybePromise","then","isAsyncModuleExt","turbopackQueues","createPromise","reject","promise","Promise","res","rej","installCompressedModuleFactories","chunkModules","offset","moduleFactories","newModuleId","end","moduleFactoryFn","existingGroupFactory","existingFactory","factoryToInstall","didInstallFactory","j1","id1","has","applyModuleFactoryName","turbopackExports","turbopackError","resolveQueue","queue","status","forEach","fn","queueCount","wrapDeps","deps","dep","assign","_obj","err","_obj1","asyncModule","body","hasAwait","depQueues","Set","_createPromise","rawPromise","attributes","handleAsyncDependencies","currentDeps","getResult","d","fnQueue","q","add","asyncResult","a","relativeURL","inputUrl","realUrl","URL","values","href","pathname","replace","origin","protocol","toString","toJSON","_args","key1","configurable","U","invariant","never","computeMessage","factoryNotAvailableMessage","sourceType","sourceData","instantiationReason","requireStub","_moduleId","z","g","globalThis","factory"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 840, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * Turbopack *browser* ECMAScript runtimes.\n *\n * It will be appended to the runtime code of each runtime right after the\n * shared runtime utils.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime/runtime-utils.ts\" />\n\n// Used in WebWorkers to tell the runtime about the chunk suffix\ndeclare var TURBOPACK_ASSET_SUFFIX: string\n// Used in WebWorkers to tell the runtime about the current chunk url since it\n// can't be detected via `document.currentScript`. Note it's stored in reversed\n// order to use `push` and `pop`\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\n\n// Injected by rust code\ndeclare var CHUNK_BASE_PATH: string\ndeclare var ASSET_SUFFIX: string\ndeclare var WORKER_FORWARDED_GLOBALS: string[]\n\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\n  R: ResolvePathFromModule\n}\n\nconst browserContextPrototype =\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\n\n// Provided by build or dev base\ndeclare function instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module\n\ntype RuntimeParams = {\n  otherChunks: ChunkData[]\n  runtimeModuleIds: ModuleId[]\n}\n\ntype ChunkRegistrationChunk =\n  | ChunkPath\n  | { getAttribute: (name: string) => string | null }\n  | undefined\n\ntype ChunkRegistration = [\n  chunkPath: ChunkRegistrationChunk,\n  ...([RuntimeParams] | CompressedModuleFactories),\n]\n\ntype ChunkList = {\n  script: ChunkRegistrationChunk\n  chunks: ChunkData[]\n  source: 'entry' | 'dynamic'\n}\n\ninterface RuntimeBackend {\n  registerChunk: (\n    chunkPath: ChunkPath | ChunkScript,\n    params?: RuntimeParams\n  ) => void\n  /**\n   * Returns the same Promise for the same chunk URL.\n   */\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\n  loadWebAssembly: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module,\n    importsObj: WebAssembly.Imports\n  ) => Promise<Exports>\n  loadWebAssemblyModule: (\n    sourceType: SourceType,\n    sourceData: SourceData,\n    wasmChunkPath: ChunkPath,\n    edgeModule: () => WebAssembly.Module\n  ) => Promise<WebAssembly.Module>\n}\n\ninterface DevRuntimeBackend {\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\n  restart: () => void\n}\n\nconst moduleFactories: ModuleFactories = new Map()\ncontextPrototype.M = moduleFactories\n\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\n\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\n\nfunction loadChunk(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkData: ChunkData\n): Promise<void> {\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\n}\nbrowserContextPrototype.l = loadChunk\n\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\n}\n\nasync function loadChunkInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkData: ChunkData\n): Promise<void> {\n  if (typeof chunkData === 'string') {\n    return loadChunkPath(sourceType, sourceData, chunkData)\n  }\n\n  const includedList = chunkData.included || []\n  const modulesPromises = includedList.map((included) => {\n    if (moduleFactories.has(included)) return true\n    return availableModules.get(included)\n  })\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\n    // When all included items are already loaded or loading, we can skip loading ourselves\n    await Promise.all(modulesPromises)\n    return\n  }\n\n  const includedModuleChunksList = chunkData.moduleChunks || []\n  const moduleChunksPromises = includedModuleChunksList\n    .map((included) => {\n      // TODO(alexkirsz) Do we need this check?\n      // if (moduleFactories[included]) return true;\n      return availableModuleChunks.get(included)\n    })\n    .filter((p) => p)\n\n  let promise: Promise<unknown>\n  if (moduleChunksPromises.length > 0) {\n    // Some module chunks are already loaded or loading.\n\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\n      await Promise.all(moduleChunksPromises)\n      return\n    }\n\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\n    for (const moduleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(moduleChunk)) {\n        moduleChunksToLoad.add(moduleChunk)\n      }\n    }\n\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\n\n      availableModuleChunks.set(moduleChunkToLoad, promise)\n\n      moduleChunksPromises.push(promise)\n    }\n\n    promise = Promise.all(moduleChunksPromises)\n  } else {\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\n\n    // Mark all included module chunks as loading if they are not already loaded or loading.\n    for (const includedModuleChunk of includedModuleChunksList) {\n      if (!availableModuleChunks.has(includedModuleChunk)) {\n        availableModuleChunks.set(includedModuleChunk, promise)\n      }\n    }\n  }\n\n  for (const included of includedList) {\n    if (!availableModules.has(included)) {\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n      availableModules.set(included, promise)\n    }\n  }\n\n  await promise\n}\n\nconst loadedChunk = Promise.resolve(undefined)\nconst instrumentedBackendLoadChunks = new WeakMap<\n  Promise<any>,\n  Promise<any> | typeof loadedChunk\n>()\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  chunkUrl: ChunkUrl\n) {\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\n}\nbrowserContextPrototype.L = loadChunkByUrl\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkByUrlInternal(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkUrl: ChunkUrl\n): Promise<any> {\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\n  let entry = instrumentedBackendLoadChunks.get(thenable)\n  if (entry === undefined) {\n    const resolve = instrumentedBackendLoadChunks.set.bind(\n      instrumentedBackendLoadChunks,\n      thenable,\n      loadedChunk\n    )\n    entry = thenable.then(resolve).catch((cause) => {\n      let loadReason: string\n      switch (sourceType) {\n        case SourceType.Runtime:\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\n          break\n        case SourceType.Parent:\n          loadReason = `from module ${sourceData}`\n          break\n        case SourceType.Update:\n          loadReason = 'from an HMR update'\n          break\n        default:\n          invariant(\n            sourceType,\n            (sourceType) => `Unknown source type: ${sourceType}`\n          )\n      }\n      let error = new Error(\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\n          cause ? `: ${cause}` : ''\n        }`,\n        cause ? { cause } : undefined\n      )\n      error.name = 'ChunkLoadError'\n      throw error\n    })\n    instrumentedBackendLoadChunks.set(thenable, entry)\n  }\n\n  return entry\n}\n\n// Do not make this async. React relies on referential equality of the returned Promise.\nfunction loadChunkPath(\n  sourceType: SourceType,\n  sourceData: SourceData,\n  chunkPath: ChunkPath\n): Promise<void> {\n  const url = getChunkRelativeUrl(chunkPath)\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\n}\n\n/**\n * Returns an absolute url to an asset.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string\n): string {\n  const exported = this.r(moduleId)\n  return exported?.default ?? exported\n}\nbrowserContextPrototype.R = resolvePathFromModule\n\n/**\n * no-op for browser\n * @param modulePath\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  return `/ROOT/${modulePath ?? ''}`\n}\nbrowserContextPrototype.P = resolveAbsolutePath\n\n/**\n * Exports a URL with the static suffix appended.\n */\nfunction exportUrl(\n  this: TurbopackBrowserBaseContext<Module>,\n  url: string,\n  id: ModuleId | undefined\n) {\n  exportValue.call(this, `${url}${ASSET_SUFFIX}`, id)\n}\nbrowserContextPrototype.q = exportUrl\n\n/**\n * Creates a worker by instantiating the given WorkerConstructor with the\n * appropriate URL and options.\n *\n * The entrypoint is a pre-compiled worker runtime file. The params configure\n * which module chunks to load and which module to run as the entry point.\n *\n * The params are a JSON array of the following structure:\n * `[TURBOPACK_NEXT_CHUNK_URLS, ASSET_SUFFIX, ...WORKER_FORWARDED_GLOBALS values]`\n *\n * @param WorkerConstructor The Worker or SharedWorker constructor\n * @param entrypoint URL path to the worker entrypoint chunk\n * @param moduleChunks list of module chunk paths to load\n * @param workerOptions options to pass to the Worker constructor (optional)\n */\nfunction createWorker(\n  WorkerConstructor: { new (url: URL, options?: object): Worker },\n  entrypoint: ChunkPath,\n  moduleChunks: ChunkPath[],\n  workerOptions?: object\n): Worker {\n  const isSharedWorker = WorkerConstructor.name === 'SharedWorker'\n\n  const chunkUrls = moduleChunks\n    .map((chunk) => getChunkRelativeUrl(chunk))\n    .reverse()\n  const params: unknown[] = [chunkUrls, ASSET_SUFFIX]\n  for (const globalName of WORKER_FORWARDED_GLOBALS) {\n    params.push((globalThis as Record<string, unknown>)[globalName])\n  }\n\n  const url = new URL(getChunkRelativeUrl(entrypoint), location.origin)\n  const paramsJson = JSON.stringify(params)\n  if (isSharedWorker) {\n    url.searchParams.set('params', paramsJson)\n  } else {\n    url.hash = '#params=' + encodeURIComponent(paramsJson)\n  }\n\n  // Remove type: \"module\" from options since our worker entrypoint is not a module\n  const options = workerOptions\n    ? { ...workerOptions, type: undefined }\n    : undefined\n  return new WorkerConstructor(url, options)\n}\nbrowserContextPrototype.b = createWorker\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n/**\n * Returns the URL relative to the origin where a chunk can be fetched from.\n */\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\n  return `${CHUNK_BASE_PATH}${chunkPath\n    .split('/')\n    .map((p) => encodeURIComponent(p))\n    .join('/')}${ASSET_SUFFIX}` as ChunkUrl\n}\n\n/**\n * Return the ChunkPath from a ChunkScript.\n */\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\nfunction getPathFromScript(\n  chunkScript: ChunkListPath | ChunkListScript\n): ChunkListPath\nfunction getPathFromScript(\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\n): ChunkPath | ChunkListPath {\n  if (typeof chunkScript === 'string') {\n    return chunkScript as ChunkPath | ChunkListPath\n  }\n  const chunkUrl = chunkScript.src!\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\n  const path = src.startsWith(CHUNK_BASE_PATH)\n    ? src.slice(CHUNK_BASE_PATH.length)\n    : src\n  return path as ChunkPath | ChunkListPath\n}\n\n/**\n * Return the ChunkUrl from a ChunkScript.\n */\nfunction getUrlFromScript(chunk: ChunkPath | ChunkScript): ChunkUrl {\n  if (typeof chunk === 'string') {\n    return getChunkRelativeUrl(chunk)\n  } else {\n    // This is already exactly what we want\n    return chunk.src! as ChunkUrl\n  }\n}\n\n/**\n * Determine the chunk to register. Note that this function has side-effects!\n */\nfunction getChunkFromRegistration(\n  chunk: ChunkRegistrationChunk\n): ChunkPath | CurrentScript {\n  if (typeof chunk === 'string') {\n    return chunk\n  } else if (!chunk) {\n    if (typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined') {\n      return { src: TURBOPACK_NEXT_CHUNK_URLS.pop()! } as CurrentScript\n    } else {\n      throw new Error('chunk path empty but not in a worker')\n    }\n  } else {\n    return { src: chunk.getAttribute('src')! } as CurrentScript\n  }\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n */\nfunction isCss(chunkUrl: ChunkUrl): boolean {\n  return regexCssUrl.test(chunkUrl)\n}\n\nfunction loadWebAssembly(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  return BACKEND.loadWebAssembly(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule,\n    importsObj\n  )\n}\ncontextPrototype.w = loadWebAssembly\n\nfunction loadWebAssemblyModule(\n  this: TurbopackBaseContext<Module>,\n  chunkPath: ChunkPath,\n  edgeModule: () => WebAssembly.Module\n): Promise<WebAssembly.Module> {\n  return BACKEND.loadWebAssemblyModule(\n    SourceType.Parent,\n    this.m.id,\n    chunkPath,\n    edgeModule\n  )\n}\ncontextPrototype.u = loadWebAssemblyModule\n"],"names":["browserContextPrototype","Context","prototype","moduleFactories","Map","contextPrototype","M","availableModules","availableModuleChunks","loadChunk","chunkData","loadChunkInternal","SourceType","Parent","m","id","l","loadInitialChunk","chunkPath","Runtime","sourceType","sourceData","includedList","modulesPromises","includedModuleChunksList","moduleChunksPromises","promise","moduleChunksToLoad","_iteratorError","moduleChunk","_iteratorError1","moduleChunkToLoad","promise1","_iteratorError2","includedModuleChunk","_iteratorError3","included","loadChunkPath","map","has","get","length","every","p","Promise","all","moduleChunks","filter","Set","add","set","push","path","loadedChunk","resolve","undefined","instrumentedBackendLoadChunks","WeakMap","loadChunkByUrl","chunkUrl","loadChunkByUrlInternal","L","thenable","BACKEND","loadChunkCached","entry","bind","then","catch","cause","loadReason","Update","invariant","error","Error","name","url","getChunkRelativeUrl","resolvePathFromModule","moduleId","exported","r","default","R","resolveAbsolutePath","modulePath","P","exportUrl","exportValue","call","ASSET_SUFFIX","q","createWorker","WorkerConstructor","entrypoint","workerOptions","isSharedWorker","chunkUrls","chunk","reverse","params","WORKER_FORWARDED_GLOBALS","globalName","globalThis","URL","location","origin","paramsJson","JSON","stringify","searchParams","hash","encodeURIComponent","options","type","b","instantiateRuntimeModule","instantiateModule","CHUNK_BASE_PATH","split","join","getPathFromScript","chunkScript","src","decodeURIComponent","replace","startsWith","slice","getUrlFromScript","getChunkFromRegistration","TURBOPACK_NEXT_CHUNK_URLS","pop","getAttribute","regexJsUrl","isJs","chunkUrlOrPath","test","regexCssUrl","isCss","loadWebAssembly","edgeModule","importsObj","w","loadWebAssemblyModule","u"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1409, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/base/build-base.ts"],"sourcesContent":["/// <reference path=\"./runtime-base.ts\" />\n/// <reference path=\"./dummy.ts\" />\n\nconst moduleCache: ModuleCache<Module> = {}\ncontextPrototype.c = moduleCache\n\n/**\n * Gets or instantiates a runtime module.\n */\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module {\n  const module = moduleCache[moduleId]\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// Used by the backend\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\n  Module\n> = (id, sourceModule) => {\n  const module = moduleCache[id]\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\n}\n\nfunction instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): Module {\n  const moduleFactory = moduleFactories.get(id)\n  if (typeof moduleFactory !== 'function') {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    throw new Error(factoryNotAvailableMessage(id, sourceType, sourceData))\n  }\n\n  const module: Module = createModuleObject(id)\n  const exports = module.exports\n\n  moduleCache[id] = module\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  const context = new (Context as any as ContextConstructor<Module>)(\n    module,\n    exports\n  )\n  try {\n    moduleFactory(context, module, exports)\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction registerChunk(registration: ChunkRegistration) {\n  const chunk = getChunkFromRegistration(registration[0]) as\n    | ChunkScript\n    | ChunkPath\n  let runtimeParams: RuntimeParams | undefined\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n  if (registration.length === 2) {\n    runtimeParams = registration[1] as RuntimeParams\n  } else {\n    runtimeParams = undefined\n    installCompressedModuleFactories(\n      registration as CompressedModuleFactories,\n      /* offset= */ 1,\n      moduleFactories\n    )\n  }\n\n  return BACKEND.registerChunk(chunk, runtimeParams)\n}\n"],"names":["moduleCache","contextPrototype","c","getOrInstantiateRuntimeModule","chunkPath","moduleId","module","error","instantiateModule","SourceType","Runtime","getOrInstantiateModuleFromParent","id","sourceModule","Parent","sourceType","sourceData","moduleFactory","moduleFactories","get","Error","factoryNotAvailableMessage","createModuleObject","exports","context","Context","namespaceObject","interopEsm","registerChunk","registration","chunk","getChunkFromRegistration","runtimeParams","length","undefined","installCompressedModuleFactories","BACKEND"],"mappings":"AAAA,0CAA0C;AAC1C,mCAAmC;AAEnC,IAAMA,cAAmC,CAAC;AAC1CC,iBAAiBC,CAAC,GAAGF;AAErB;;CAEC,GACD,aAAa;AACb,6DAA6D;AAC7D,SAASG,8BACPC,SAAoB,EACpBC,QAAkB;IAElB,IAAMC,SAASN,WAAW,CAACK,SAAS;IACpC,IAAIC,QAAQ;QACV,IAAIA,OAAOC,KAAK,EAAE;YAChB,MAAMD,OAAOC,KAAK;QACpB;QACA,OAAOD;IACT;IAEA,OAAOE,kBAAkBH,UAAUI,WAAWC,OAAO,EAAEN;AACzD;AAEA;;CAEC,GACD,sBAAsB;AACtB,aAAa;AACb,6DAA6D;AAC7D,IAAMO,mCAEF,0CAACC,IAAIC;IACP,IAAMP,SAASN,WAAW,CAACY,GAAG;IAE9B,IAAIN,QAAQ;QACV,IAAIA,OAAOC,KAAK,EAAE;YAChB,MAAMD,OAAOC,KAAK;QACpB;QACA,OAAOD;IACT;IAEA,OAAOE,kBAAkBI,IAAIH,WAAWK,MAAM,EAAED,aAAaD,EAAE;AACjE;AAEA,SAASJ,kBACPI,EAAY,EACZG,UAAsB,EACtBC,UAAsB;IAEtB,IAAMC,gBAAgBC,gBAAgBC,GAAG,CAACP;IAC1C,IAAI,OAAOK,kBAAkB,YAAY;QACvC,sEAAsE;QACtE,0EAA0E;QAC1E,mDAAmD;QACnD,MAAM,IAAIG,MAAMC,2BAA2BT,IAAIG,YAAYC;IAC7D;IAEA,IAAMV,SAAiBgB,mBAAmBV;IAC1C,IAAMW,UAAUjB,OAAOiB,OAAO;IAE9BvB,WAAW,CAACY,GAAG,GAAGN;IAElB,4EAA4E;IAC5E,IAAMkB,UAAU,IAAKC,QACnBnB,QACAiB;IAEF,IAAI;QACFN,cAAcO,SAASlB,QAAQiB;IACjC,EAAE,OAAOhB,OAAO;QACdD,OAAOC,KAAK,GAAGA;QACf,MAAMA;IACR;IAEA,IAAID,OAAOoB,eAAe,IAAIpB,OAAOiB,OAAO,KAAKjB,OAAOoB,eAAe,EAAE;QACvE,yDAAyD;QACzDC,WAAWrB,OAAOiB,OAAO,EAAEjB,OAAOoB,eAAe;IACnD;IAEA,OAAOpB;AACT;AAEA,6DAA6D;AAC7D,SAASsB,cAAcC,YAA+B;IACpD,IAAMC,QAAQC,yBAAyBF,YAAY,CAAC,EAAE;IAGtD,IAAIG;IACJ,8GAA8G;IAC9G,IAAIH,aAAaI,MAAM,KAAK,GAAG;QAC7BD,gBAAgBH,YAAY,CAAC,EAAE;IACjC,OAAO;QACLG,gBAAgBE;QAChBC,iCACEN,cACA,WAAW,GAAG,GACdX;IAEJ;IAEA,OAAOkB,QAAQR,aAAa,CAACE,OAAOE;AACtC","ignoreList":[0]}},
    {"offset": {"line": 1480, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts"],"sourcesContent":["/**\n * This file contains the runtime code specific to the Turbopack ECMAScript DOM runtime.\n *\n * It will be appended to the base runtime code.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/runtime/runtime-types.d.ts\" />\n\nfunction getAssetSuffixFromScriptSrc() {\n  // TURBOPACK_ASSET_SUFFIX is set in web workers\n  return (\n    (self.TURBOPACK_ASSET_SUFFIX ??\n      document?.currentScript\n        ?.getAttribute?.('src')\n        ?.replace(/^(.*(?=\\?)|^.*$)/, '')) ||\n    ''\n  )\n}\n\ntype ChunkResolver = {\n  resolved: boolean\n  loadingStarted: boolean\n  resolve: () => void\n  reject: (error?: Error) => void\n  promise: Promise<any>\n}\n\nlet BACKEND: RuntimeBackend\n\n/**\n * Maps chunk paths to the corresponding resolver.\n */\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\n\n;(() => {\n  BACKEND = {\n    async registerChunk(chunk, params) {\n      let chunkPath = getPathFromScript(chunk)\n      let chunkUrl = getUrlFromScript(chunk)\n\n      const resolver = getOrCreateResolver(chunkUrl)\n      resolver.resolve()\n\n      if (params == null) {\n        return\n      }\n\n      for (const otherChunkData of params.otherChunks) {\n        const otherChunkPath = getChunkPath(otherChunkData)\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath)\n\n        // Chunk might have started loading, so we want to avoid triggering another load.\n        getOrCreateResolver(otherChunkUrl)\n      }\n\n      // This waits for chunks to be loaded, but also marks included items as available.\n      await Promise.all(\n        params.otherChunks.map((otherChunkData) =>\n          loadInitialChunk(chunkPath, otherChunkData)\n        )\n      )\n\n      if (params.runtimeModuleIds.length > 0) {\n        for (const moduleId of params.runtimeModuleIds) {\n          getOrInstantiateRuntimeModule(chunkPath, moduleId)\n        }\n      }\n    },\n\n    /**\n     * Loads the given chunk, and returns a promise that resolves once the chunk\n     * has been loaded.\n     */\n    loadChunkCached(sourceType: SourceType, chunkUrl: ChunkUrl) {\n      return doLoadChunk(sourceType, chunkUrl)\n    },\n\n    async loadWebAssembly(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module,\n      importsObj: WebAssembly.Imports\n    ): Promise<Exports> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      const { instance } = await WebAssembly.instantiateStreaming(\n        req,\n        importsObj\n      )\n\n      return instance.exports\n    },\n\n    async loadWebAssemblyModule(\n      _sourceType: SourceType,\n      _sourceData: SourceData,\n      wasmChunkPath: ChunkPath,\n      _edgeModule: () => WebAssembly.Module\n    ): Promise<WebAssembly.Module> {\n      const req = fetchWebAssembly(wasmChunkPath)\n\n      return await WebAssembly.compileStreaming(req)\n    },\n  }\n\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\n    let resolver = chunkResolvers.get(chunkUrl)\n    if (!resolver) {\n      let resolve: () => void\n      let reject: (error?: Error) => void\n      const promise = new Promise<void>((innerResolve, innerReject) => {\n        resolve = innerResolve\n        reject = innerReject\n      })\n      resolver = {\n        resolved: false,\n        loadingStarted: false,\n        promise,\n        resolve: () => {\n          resolver!.resolved = true\n          resolve()\n        },\n        reject: reject!,\n      }\n      chunkResolvers.set(chunkUrl, resolver)\n    }\n    return resolver\n  }\n\n  /**\n   * Loads the given chunk, and returns a promise that resolves once the chunk\n   * has been loaded.\n   */\n  function doLoadChunk(sourceType: SourceType, chunkUrl: ChunkUrl) {\n    const resolver = getOrCreateResolver(chunkUrl)\n    if (resolver.loadingStarted) {\n      return resolver.promise\n    }\n\n    if (sourceType === SourceType.Runtime) {\n      // We don't need to load chunks references from runtime code, as they're already\n      // present in the DOM.\n      resolver.loadingStarted = true\n\n      if (isCss(chunkUrl)) {\n        // CSS chunks do not register themselves, and as such must be marked as\n        // loaded instantly.\n        resolver.resolve()\n      }\n\n      // We need to wait for JS chunks to register themselves within `registerChunk`\n      // before we can start instantiating runtime modules, hence the absence of\n      // `resolver.resolve()` in this branch.\n\n      return resolver.promise\n    }\n\n    if (typeof importScripts === 'function') {\n      // We're in a web worker\n      if (isCss(chunkUrl)) {\n        // ignore\n      } else if (isJs(chunkUrl)) {\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl)\n        importScripts(chunkUrl)\n      } else {\n        throw new Error(\n          `can't infer type of chunk from URL ${chunkUrl} in worker`\n        )\n      }\n    } else {\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n      const decodedChunkUrl = decodeURI(chunkUrl)\n\n      if (isCss(chunkUrl)) {\n        const previousLinks = document.querySelectorAll(\n          `link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousLinks.length > 0) {\n          // CSS chunks do not register themselves, and as such must be marked as\n          // loaded instantly.\n          resolver.resolve()\n        } else {\n          const link = document.createElement('link')\n          link.rel = 'stylesheet'\n          link.href = chunkUrl\n          link.onerror = () => {\n            resolver.reject()\n          }\n          link.onload = () => {\n            // CSS chunks do not register themselves, and as such must be marked as\n            // loaded instantly.\n            resolver.resolve()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(link)\n        }\n      } else if (isJs(chunkUrl)) {\n        const previousScripts = document.querySelectorAll(\n          `script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`\n        )\n        if (previousScripts.length > 0) {\n          // There is this edge where the script already failed loading, but we\n          // can't detect that. The Promise will never resolve in this case.\n          for (const script of Array.from(previousScripts)) {\n            script.addEventListener('error', () => {\n              resolver.reject()\n            })\n          }\n        } else {\n          const script = document.createElement('script')\n          script.src = chunkUrl\n          // We'll only mark the chunk as loaded once the script has been executed,\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\n          // this branch.\n          script.onerror = () => {\n            resolver.reject()\n          }\n          // Append to the `head` for webpack compatibility.\n          document.head.appendChild(script)\n        }\n      } else {\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\n      }\n    }\n\n    resolver.loadingStarted = true\n    return resolver.promise\n  }\n\n  function fetchWebAssembly(wasmChunkPath: ChunkPath) {\n    return fetch(getChunkRelativeUrl(wasmChunkPath))\n  }\n})()\n"],"names":["getAssetSuffixFromScriptSrc","_self_TURBOPACK_ASSET_SUFFIX","_document_currentScript_getAttribute","TURBOPACK_ASSET_SUFFIX","currentScript","getAttribute","replace","BACKEND","chunkResolvers","Map","registerChunk","chunk","params","chunkPath","chunkUrl","resolver","_iteratorError","otherChunkData","otherChunkPath","otherChunkUrl","_iteratorError1","moduleId","getPathFromScript","getUrlFromScript","getOrCreateResolver","resolve","otherChunks","getChunkPath","getChunkRelativeUrl","Promise","all","map","loadInitialChunk","runtimeModuleIds","length","getOrInstantiateRuntimeModule","loadChunkCached","sourceType","doLoadChunk","loadWebAssembly","_sourceType","_sourceData","wasmChunkPath","_edgeModule","importsObj","req","instance","fetchWebAssembly","WebAssembly","instantiateStreaming","exports","loadWebAssemblyModule","compileStreaming","get","reject","promise","innerResolve","innerReject","resolved","loadingStarted","resolve1","set","SourceType","Runtime","isCss","importScripts","isJs","self","TURBOPACK_NEXT_CHUNK_URLS","push","Error","decodedChunkUrl","decodeURI","previousLinks","document","querySelectorAll","link","createElement","rel","href","onerror","onload","head","appendChild","previousScripts","Array","from","script","addEventListener","script1","src","fetch"],"mappings":"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","ignoreList":[0]}}]
}