{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n/**\n * Describes why a module was instantiated.\n * Shared between browser and Node.js runtimes.\n */\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   * SourceData is a ChunkPath.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   * SourceData is a ModuleId.\n   */\n  Parent = 1,\n  /**\n   * The module was instantiated because it was included in a chunk's hot module\n   * update.\n   * SourceData is an array of ModuleIds or undefined.\n   */\n  Update = 2,\n}\n\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\n// @ts-ignore Defined in `hmr-runtime.ts` (dev mode only)\ndeclare let devModuleCache: Record<ModuleId, any> | undefined\n\n/**\n * Flag indicating which module object type to create when a module is merged. Set to `true`\n * by each runtime that uses ModuleWithDirection (browser dev-base.ts, nodejs dev-base.ts,\n * nodejs build-base.ts). Browser production (build-base.ts) leaves it as `false` since it\n * uses plain Module objects.\n */\nlet createModuleWithDirectionFlag = false\n\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\n\n/**\n * Constructs the `__turbopack_context__` object for a module.\n */\nfunction Context(\n  this: TurbopackBaseContext<Module>,\n  module: Module,\n  exports: Exports\n) {\n  this.m = module\n  // We need to store this here instead of accessing it from the module object to:\n  // 1. Make it available to factories directly, since we rewrite `this` to\n  //    `__turbopack_context__.e` in CJS modules.\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\n  //    can still access the original exports object from functions like\n  //    `esmExport`\n  // Ideally we could find a new approach for async modules and drop this property altogether.\n  this.e = exports\n}\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: string): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: string): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\n  moduleId: M['id'],\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\nfunction getOverwrittenModule(\n  moduleCache: ModuleCache<Module>,\n  id: ModuleId\n): Module {\n  let module = moduleCache[id]\n  if (!module) {\n    if (createModuleWithDirectionFlag) {\n      // set in development modes for hmr support\n      module = createModuleWithDirection(id)\n    } else {\n      module = createModuleObject(id)\n    }\n    moduleCache[id] = module\n  }\n  return module\n}\n\n/**\n * Creates the module object. Only done here to ensure all module objects have the same shape.\n */\nfunction createModuleObject(id: ModuleId): Module {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n  }\n}\n\nfunction createModuleWithDirection(id: ModuleId): ModuleWithDirection {\n  return {\n    exports: {},\n    error: undefined,\n    id,\n    namespaceObject: undefined,\n    parents: [],\n    children: [],\n  }\n}\n\ntype BindingTag = 0\nconst BindingTag_Value = 0 as BindingTag\n\n// an arbitrary sequence of bindings as\n// - a prop name\n// - BindingTag_Value, a value to be bound directly, or\n// - 1 or 2 functions to bind as getters and sdetters\ntype EsmBindings = Array<\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\n>\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(exports: Exports, bindings: EsmBindings) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  let i = 0\n  while (i < bindings.length) {\n    const propName = bindings[i++] as string\n    const tagOrFunction = bindings[i++]\n    if (typeof tagOrFunction === 'number') {\n      if (tagOrFunction === BindingTag_Value) {\n        defineProp(exports, propName, {\n          value: bindings[i++],\n          enumerable: true,\n          writable: false,\n        })\n      } else {\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\n      }\n    } else {\n      const getterFn = tagOrFunction as () => unknown\n      if (typeof bindings[i] === 'function') {\n        const setterFn = bindings[i++] as (v: unknown) => void\n        defineProp(exports, propName, {\n          get: getterFn,\n          set: setterFn,\n          enumerable: true,\n        })\n      } else {\n        defineProp(exports, propName, {\n          get: getterFn,\n          enumerable: true,\n        })\n      }\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  this: TurbopackBaseContext<Module>,\n  bindings: EsmBindings,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Module['exports']\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  module.namespaceObject = exports\n  esm(exports, bindings)\n}\ncontextPrototype.s = esmExport\n\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\nfunction ensureDynamicExports(\n  module: Module,\n  exports: Exports\n): ReexportedObjects {\n  let reexportedObjects: ReexportedObjects | undefined =\n    REEXPORTED_OBJECTS.get(module)\n\n  if (!reexportedObjects) {\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n  return reexportedObjects\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  this: TurbopackBaseContext<Module>,\n  object: Record<string, any>,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  let exports: Exports\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n    exports = module.exports\n  } else {\n    module = this.m\n    exports = this.e\n  }\n  const reexportedObjects = ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    reexportedObjects.push(object)\n  }\n}\ncontextPrototype.j = dynamicExport\n\nfunction exportValue(\n  this: TurbopackBaseContext<Module>,\n  value: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = value\n}\ncontextPrototype.v = exportValue\n\nfunction exportNamespace(\n  this: TurbopackBaseContext<Module>,\n  namespace: any,\n  id: ModuleId | undefined\n) {\n  let module: Module\n  if (id != null) {\n    module = getOverwrittenModule(this.c, id)\n  } else {\n    module = this.m\n  }\n  module.exports = module.namespaceObject = namespace\n}\ncontextPrototype.n = exportNamespace\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const bindings: EsmBindings = []\n  let defaultLocation = -1\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      bindings.push(key, createGetter(raw, key))\n      if (defaultLocation === -1 && key === 'default') {\n        defaultLocation = bindings.length - 1\n      }\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && defaultLocation >= 0)) {\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\n    if (defaultLocation >= 0) {\n      // Replace the getter with the value\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\n    } else {\n      bindings.push('default', BindingTag_Value, raw)\n    }\n  }\n\n  esm(ns, bindings)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, this.m)\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\ncontextPrototype.i = esmImport\n\nfunction asyncLoader(\n  this: TurbopackBaseContext<Module>,\n  moduleId: ModuleId\n): Promise<Exports> {\n  const loader = this.r(moduleId) as (\n    importFunction: EsmImport\n  ) => Promise<Exports>\n  return loader(esmImport.bind(this))\n}\ncontextPrototype.A = asyncLoader\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\ncontextPrototype.t = runtimeRequire\n\nfunction commonJsRequire(\n  this: TurbopackBaseContext<Module>,\n  id: ModuleId\n): Exports {\n  return getOrInstantiateModuleFromParent(id, this.m).exports\n}\ncontextPrototype.r = commonJsRequire\n\n/**\n * Remove fragments and query parameters since they are never part of the context map keys\n *\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\n * here as well.\n */\nfunction parseRequest(request: string): string {\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n  const hashIndex = request.indexOf('#')\n  if (hashIndex !== -1) {\n    request = request.substring(0, hashIndex)\n  }\n\n  const queryIndex = request.indexOf('?')\n  if (queryIndex !== -1) {\n    request = request.substring(0, queryIndex)\n  }\n\n  return request\n}\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: string): Exports {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): string[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: string): ModuleId => {\n    id = parseRequest(id)\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: string) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\ncontextPrototype.f = moduleContext\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n// The CompressedModuleFactories format is\n// - 1 or more module ids\n// - a module factory function\n// So walking this is a little complex but the flat structure is also fast to\n// traverse, we can use `typeof` operators to distinguish the two cases.\nfunction installCompressedModuleFactories(\n  chunkModules: CompressedModuleFactories,\n  offset: number,\n  moduleFactories: ModuleFactories,\n  newModuleId?: (id: ModuleId) => void\n) {\n  let i = offset\n  while (i < chunkModules.length) {\n    let end = i + 1\n    // Find our factory function\n    while (\n      end < chunkModules.length &&\n      typeof chunkModules[end] !== 'function'\n    ) {\n      end++\n    }\n    if (end === chunkModules.length) {\n      throw new Error('malformed chunk format, expected a factory function')\n    }\n\n    // Install the factory for each module ID that doesn't already have one.\n    // When some IDs in this group already have a factory, reuse that existing\n    // group factory for the missing IDs to keep all IDs in the group consistent.\n    // Otherwise, install the factory from this chunk.\n    const moduleFactoryFn = chunkModules[end] as Function\n    let existingGroupFactory: Function | undefined = undefined\n    for (let j = i; j < end; j++) {\n      const id = chunkModules[j] as ModuleId\n      const existingFactory = moduleFactories.get(id)\n      if (existingFactory) {\n        existingGroupFactory = existingFactory\n        break\n      }\n    }\n    const factoryToInstall = existingGroupFactory ?? moduleFactoryFn\n\n    let didInstallFactory = false\n    for (let j = i; j < end; j++) {\n      const id = chunkModules[j] as ModuleId\n      if (!moduleFactories.has(id)) {\n        if (!didInstallFactory) {\n          if (factoryToInstall === moduleFactoryFn) {\n            applyModuleFactoryName(moduleFactoryFn)\n          }\n          didInstallFactory = true\n        }\n        moduleFactories.set(id, factoryToInstall)\n        newModuleId?.(id)\n      }\n    }\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  this: TurbopackBaseContext<Module>,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const module = this.m\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\ncontextPrototype.a = asyncModule\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\nrelativeURL.prototype = URL.prototype\ncontextPrototype.U = relativeURL\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * Constructs an error message for when a module factory is not available.\n */\nfunction factoryNotAvailableMessage(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): string {\n  let instantiationReason: string\n  switch (sourceType) {\n    case SourceType.Runtime:\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\n      break\n    case SourceType.Parent:\n      instantiationReason = `because it was required from module ${sourceData}`\n      break\n    case SourceType.Update:\n      instantiationReason = 'because of an HMR update'\n      break\n    default:\n      invariant(\n        sourceType,\n        (sourceType) => `Unknown source type: ${sourceType}`\n      )\n  }\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\ncontextPrototype.z = requireStub\n\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\ncontextPrototype.g = globalThis\n\ntype ContextConstructor<M> = {\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\n}\n\nfunction applyModuleFactoryName(factory: Function) {\n  // Give the module factory a nice name to improve stack traces.\n  Object.defineProperty(factory, 'name', {\n    value: 'module evaluation',\n  })\n}\n"],"names":["SourceType","createModuleWithDirectionFlag","REEXPORTED_OBJECTS","WeakMap","Context","module","exports","m","e","contextPrototype","prototype","hasOwnProperty","Object","toStringTag","Symbol","defineProp","obj","name","options","call","defineProperty","getOverwrittenModule","moduleCache","id","createModuleWithDirection","createModuleObject","error","undefined","namespaceObject","parents","children","BindingTag_Value","esm","bindings","value","i","length","propName","tagOrFunction","enumerable","writable","Error","getterFn","setterFn","get","set","seal","esmExport","c","s","ensureDynamicExports","reexportedObjects","Proxy","target","prop","Reflect","ownKeys","keys","key","includes","push","dynamicExport","object","j","exportValue","v","exportNamespace","namespace","n","createGetter","getProto","getPrototypeOf","__proto__","LEAF_PROTOTYPES","interopEsm","raw","ns","allowExportDefault","defaultLocation","current","getOwnPropertyNames","splice","createNS","args","apply","create","esmImport","getOrInstantiateModuleFromParent","__esModule","asyncLoader","moduleId","loader","r","bind","A","runtimeRequire","require","require1","t","commonJsRequire","parseRequest","request","hashIndex","indexOf","substring","queryIndex","moduleContext","map","code","resolve","import","f","getChunkPath","chunkData","path","isPromise","maybePromise","then","isAsyncModuleExt","turbopackQueues","createPromise","reject","promise","Promise","res","rej","installCompressedModuleFactories","chunkModules","offset","moduleFactories","newModuleId","end","moduleFactoryFn","existingGroupFactory","existingFactory","factoryToInstall","didInstallFactory","has","applyModuleFactoryName","turbopackExports","turbopackError","resolveQueue","queue","status","forEach","fn","queueCount","wrapDeps","deps","dep","assign","err","asyncModule","body","hasAwait","depQueues","Set","rawPromise","attributes","handleAsyncDependencies","currentDeps","getResult","d","fnQueue","q","add","asyncResult","a","relativeURL","inputUrl","realUrl","URL","values","href","pathname","replace","origin","protocol","toString","toJSON","_args","configurable","U","invariant","never","computeMessage","factoryNotAvailableMessage","sourceType","sourceData","instantiationReason","requireStub","_moduleId","z","g","globalThis","factory"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/base-externals-utils.ts"],"sourcesContent":["/// <reference path=\"../shared/runtime/runtime-utils.ts\" />\n\n/// A 'base' utilities to support runtime can have externals.\n/// Currently this is for node.js / edge runtime both.\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\n\nasync function externalImport(id: DependencySpecifier) {\n  let raw\n  try {\n    raw = await import(id)\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`)\n  }\n\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\n    return interopEsm(raw.default, createNS(raw), true)\n  }\n\n  return raw\n}\ncontextPrototype.y = externalImport\n\nfunction externalRequire(\n  id: ModuleId,\n  thunk: () => any,\n  esm: boolean = false\n): Exports | EsmNamespaceObject {\n  let raw\n  try {\n    raw = thunk()\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`)\n  }\n\n  if (!esm || raw.__esModule) {\n    return raw\n  }\n\n  return interopEsm(raw, createNS(raw), true)\n}\n\nexternalRequire.resolve = (\n  id: string,\n  options?: {\n    paths?: string[]\n  }\n) => {\n  return require.resolve(id, options)\n}\ncontextPrototype.x = externalRequire\n"],"names":["externalImport","id","raw","err","Error","__esModule","default","interopEsm","createNS","contextPrototype","y","externalRequire","thunk","esm","resolve","options","require","x"],"mappings":"AAAA,2DAA2D;AAE3D,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAeA,eAAeC,EAAuB;IACnD,IAAIC;IACJ,IAAI;QACFA,MAAM,MAAM,MAAM,CAACD;IACrB,EAAE,OAAOE,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAIC,MAAM,CAAC,+BAA+B,EAAEH,GAAG,EAAE,EAAEE,KAAK;IAChE;IAEA,IAAID,OAAOA,IAAIG,UAAU,IAAIH,IAAII,OAAO,IAAI,aAAaJ,IAAII,OAAO,EAAE;QACpE,OAAOC,WAAWL,IAAII,OAAO,EAAEE,SAASN,MAAM;IAChD;IAEA,OAAOA;AACT;AACAO,iBAAiBC,CAAC,GAAGV;AAErB,SAASW,gBACPV,EAAY,EACZW,KAAgB,EAChBC,MAAe,KAAK;IAEpB,IAAIX;IACJ,IAAI;QACFA,MAAMU;IACR,EAAE,OAAOT,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAIC,MAAM,CAAC,+BAA+B,EAAEH,GAAG,EAAE,EAAEE,KAAK;IAChE;IAEA,IAAI,CAACU,OAAOX,IAAIG,UAAU,EAAE;QAC1B,OAAOH;IACT;IAEA,OAAOK,WAAWL,KAAKM,SAASN,MAAM;AACxC;AAEAS,gBAAgBG,OAAO,GAAG,CACxBb,IACAc;IAIA,OAAOC,QAAQF,OAAO,CAACb,IAAIc;AAC7B;AACAN,iBAAiBQ,CAAC,GAAGN","ignoreList":[0]}},
    {"offset": {"line": 621, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/node-externals-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\ndeclare var RUNTIME_PUBLIC_PATH: string\ndeclare var RELATIVE_ROOT_PATH: string\ndeclare var ASSET_PREFIX: string\n\nconst path = require('path')\n\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\n// Compute the relative path to the `distDir`.\nconst relativePathToDistRoot = path.join(\n  relativePathToRuntimeRoot,\n  RELATIVE_ROOT_PATH\n)\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\n\n/**\n * Returns an absolute path to the given module path.\n * Module path should be relative, either path to a file or a directory.\n *\n * This fn allows to calculate an absolute path for some global static values, such as\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\n * See ImportMetaBinding::code_generation for the usage.\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  if (modulePath) {\n    return path.join(ABSOLUTE_ROOT, modulePath)\n  }\n  return ABSOLUTE_ROOT\n}\nContext.prototype.P = resolveAbsolutePath\n"],"names":["path","require","relativePathToRuntimeRoot","relative","RUNTIME_PUBLIC_PATH","relativePathToDistRoot","join","RELATIVE_ROOT_PATH","RUNTIME_ROOT","resolve","__filename","ABSOLUTE_ROOT","resolveAbsolutePath","modulePath","Context","prototype","P"],"mappings":"AAAA,oDAAoD,GAMpD,MAAMA,OAAOC,QAAQ;AAErB,MAAMC,4BAA4BF,KAAKG,QAAQ,CAACC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAMC,yBAAyBL,KAAKM,IAAI,CACtCJ,2BACAK;AAEF,MAAMC,eAAeR,KAAKS,OAAO,CAACC,YAAYR;AAC9C,mGAAmG;AACnG,MAAMS,gBAAgBX,KAAKS,OAAO,CAACC,YAAYL;AAE/C;;;;;;;CAOC,GACD,SAASO,oBAAoBC,UAAmB;IAC9C,IAAIA,YAAY;QACd,OAAOb,KAAKM,IAAI,CAACK,eAAeE;IAClC;IACA,OAAOF;AACT;AACAG,QAAQC,SAAS,CAACC,CAAC,GAAGJ","ignoreList":[0]}},
    {"offset": {"line": 642, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/node-wasm-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../shared/runtime/runtime-utils.ts\" />\n\nfunction readWebAssemblyAsResponse(path: string) {\n  const { createReadStream } = require('fs') as typeof import('fs')\n  const { Readable } = require('stream') as typeof import('stream')\n\n  const stream = createReadStream(path)\n\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\n  return new Response(Readable.toWeb(stream), {\n    headers: {\n      'content-type': 'application/wasm',\n    },\n  })\n}\n\nasync function compileWebAssemblyFromPath(\n  path: string\n): Promise<WebAssembly.Module> {\n  const response = readWebAssemblyAsResponse(path)\n\n  return await WebAssembly.compileStreaming(response)\n}\n\nasync function instantiateWebAssemblyFromPath(\n  path: string,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  const response = readWebAssemblyAsResponse(path)\n\n  const { instance } = await WebAssembly.instantiateStreaming(\n    response,\n    importsObj\n  )\n\n  return instance.exports\n}\n"],"names":["readWebAssemblyAsResponse","path","createReadStream","require","Readable","stream","Response","toWeb","headers","compileWebAssemblyFromPath","response","WebAssembly","compileStreaming","instantiateWebAssemblyFromPath","importsObj","instance","instantiateStreaming","exports"],"mappings":"AAAA,oDAAoD,GAEpD,2DAA2D;AAE3D,SAASA,0BAA0BC,IAAY;IAC7C,MAAM,EAAEC,gBAAgB,EAAE,GAAGC,QAAQ;IACrC,MAAM,EAAEC,QAAQ,EAAE,GAAGD,QAAQ;IAE7B,MAAME,SAASH,iBAAiBD;IAEhC,2EAA2E;IAC3E,OAAO,IAAIK,SAASF,SAASG,KAAK,CAACF,SAAS;QAC1CG,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAeC,2BACbR,IAAY;IAEZ,MAAMS,WAAWV,0BAA0BC;IAE3C,OAAO,MAAMU,YAAYC,gBAAgB,CAACF;AAC5C;AAEA,eAAeG,+BACbZ,IAAY,EACZa,UAA+B;IAE/B,MAAMJ,WAAWV,0BAA0BC;IAE3C,MAAM,EAAEc,QAAQ,EAAE,GAAG,MAAMJ,YAAYK,oBAAoB,CACzDN,UACAI;IAGF,OAAOC,SAASE,OAAO;AACzB","ignoreList":[0]}},
    {"offset": {"line": 663, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/nodejs/runtime/runtime-base.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../../shared/runtime/runtime-utils.ts\" />\n/// <reference path=\"../../shared-node/base-externals-utils.ts\" />\n/// <reference path=\"../../shared-node/node-externals-utils.ts\" />\n/// <reference path=\"../../shared-node/node-wasm-utils.ts\" />\n/// <reference path=\"./nodejs-globals.d.ts\" />\n\n/**\n * Base Node.js runtime shared between production and development.\n * Contains chunk loading, module caching, and other non-HMR functionality.\n */\n\nprocess.env.TURBOPACK = '1'\n\nconst url = require('url') as typeof import('url')\n\nconst moduleFactories: ModuleFactories = new Map()\nconst moduleCache: ModuleCache<Module> = Object.create(null)\n\n/**\n * Returns an absolute path to the given module's id.\n */\nfunction resolvePathFromModule(\n  this: TurbopackBaseContext<Module>,\n  moduleId: string\n): string {\n  const exported = this.r(moduleId)\n  const exportedPath = exported?.default ?? exported\n  if (typeof exportedPath !== 'string') {\n    return exported as any\n  }\n\n  const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\n  const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\n\n  return url.pathToFileURL(resolved).href\n}\n\n/**\n * Exports a URL value. No suffix is added in Node.js runtime.\n */\nfunction exportUrl(\n  this: TurbopackBaseContext<Module>,\n  urlValue: string,\n  id: ModuleId | undefined\n) {\n  exportValue.call(this, urlValue, id)\n}\n\nfunction loadRuntimeChunk(sourcePath: ChunkPath, chunkData: ChunkData): void {\n  if (typeof chunkData === 'string') {\n    loadRuntimeChunkPath(sourcePath, chunkData)\n  } else {\n    loadRuntimeChunkPath(sourcePath, chunkData.path)\n  }\n}\n\nconst loadedChunks = new Set<ChunkPath>()\nconst unsupportedLoadChunk = Promise.resolve(undefined)\nconst loadedChunk: Promise<void> = Promise.resolve(undefined)\nconst chunkCache = new Map<ChunkPath, Promise<void>>()\n\nfunction clearChunkCache() {\n  chunkCache.clear()\n  loadedChunks.clear()\n}\n\nfunction loadRuntimeChunkPath(\n  sourcePath: ChunkPath,\n  chunkPath: ChunkPath\n): void {\n  if (!isJs(chunkPath)) {\n    // We only support loading JS chunks in Node.js.\n    // This branch can be hit when trying to load a CSS chunk.\n    return\n  }\n\n  if (loadedChunks.has(chunkPath)) {\n    return\n  }\n\n  try {\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n    const chunkModules: CompressedModuleFactories = require(resolved)\n    installCompressedModuleFactories(chunkModules, 0, moduleFactories)\n    loadedChunks.add(chunkPath)\n  } catch (cause) {\n    let errorMessage = `Failed to load chunk ${chunkPath}`\n\n    if (sourcePath) {\n      errorMessage += ` from runtime for chunk ${sourcePath}`\n    }\n\n    const error = new Error(errorMessage, { cause })\n    error.name = 'ChunkLoadError'\n    throw error\n  }\n}\n\nfunction loadChunkAsync<TModule extends Module>(\n  this: TurbopackBaseContext<TModule>,\n  chunkData: ChunkData\n): Promise<void> {\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\n  if (!isJs(chunkPath)) {\n    // We only support loading JS chunks in Node.js.\n    // This branch can be hit when trying to load a CSS chunk.\n    return unsupportedLoadChunk\n  }\n\n  let entry = chunkCache.get(chunkPath)\n  if (entry === undefined) {\n    try {\n      // resolve to an absolute path to simplify `require` handling\n      const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n      // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\n      // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\n      const chunkModules: CompressedModuleFactories = require(resolved)\n      installCompressedModuleFactories(chunkModules, 0, moduleFactories)\n      entry = loadedChunk\n    } catch (cause) {\n      const errorMessage = `Failed to load chunk ${chunkPath} from module ${this.m.id}`\n      const error = new Error(errorMessage, { cause })\n      error.name = 'ChunkLoadError'\n\n      // Cache the failure promise, future requests will also get this same rejection\n      entry = Promise.reject(error)\n    }\n    chunkCache.set(chunkPath, entry)\n  }\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\n  return entry\n}\ncontextPrototype.l = loadChunkAsync\n\nfunction loadChunkAsyncByUrl<TModule extends Module>(\n  this: TurbopackBaseContext<TModule>,\n  chunkUrl: string\n) {\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\n  return loadChunkAsync.call(this, path)\n}\ncontextPrototype.L = loadChunkAsyncByUrl\n\nfunction loadWebAssembly(\n  chunkPath: ChunkPath,\n  _edgeModule: () => WebAssembly.Module,\n  imports: WebAssembly.Imports\n) {\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n\n  return instantiateWebAssemblyFromPath(resolved, imports)\n}\ncontextPrototype.w = loadWebAssembly\n\nfunction loadWebAssemblyModule(\n  chunkPath: ChunkPath,\n  _edgeModule: () => WebAssembly.Module\n) {\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n\n  return compileWebAssemblyFromPath(resolved)\n}\ncontextPrototype.u = loadWebAssemblyModule\n\n/**\n * Creates a Node.js worker thread by instantiating the given WorkerConstructor\n * with the appropriate path and options, including forwarded globals.\n *\n * @param WorkerConstructor The Worker constructor from worker_threads\n * @param workerPath Path to the worker entry chunk\n * @param workerOptions options to pass to the Worker constructor (optional)\n */\nfunction createWorker(\n  WorkerConstructor: { new (path: string, options?: object): unknown },\n  workerPath: string,\n  workerOptions?: { workerData?: unknown; [key: string]: unknown }\n): unknown {\n  // Build the forwarded globals object\n  const forwardedGlobals: Record<string, unknown> = {}\n  for (const name of WORKER_FORWARDED_GLOBALS) {\n    forwardedGlobals[name] = (globalThis as Record<string, unknown>)[name]\n  }\n\n  // Merge workerData with forwarded globals\n  const existingWorkerData = workerOptions?.workerData || {}\n  const options = {\n    ...workerOptions,\n    workerData: {\n      ...(typeof existingWorkerData === 'object' ? existingWorkerData : {}),\n      __turbopack_globals__: forwardedGlobals,\n    },\n  }\n\n  return new WorkerConstructor(workerPath, options)\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n"],"names":["process","env","TURBOPACK","url","require","moduleFactories","Map","moduleCache","Object","create","resolvePathFromModule","moduleId","exported","r","exportedPath","default","strippedAssetPrefix","slice","ASSET_PREFIX","length","resolved","path","resolve","RUNTIME_ROOT","pathToFileURL","href","exportUrl","urlValue","id","exportValue","call","loadRuntimeChunk","sourcePath","chunkData","loadRuntimeChunkPath","loadedChunks","Set","unsupportedLoadChunk","Promise","undefined","loadedChunk","chunkCache","clearChunkCache","clear","chunkPath","isJs","has","chunkModules","installCompressedModuleFactories","add","cause","errorMessage","error","Error","name","loadChunkAsync","entry","get","m","reject","set","contextPrototype","l","loadChunkAsyncByUrl","chunkUrl","path1","fileURLToPath","URL","L","loadWebAssembly","_edgeModule","imports","instantiateWebAssemblyFromPath","w","loadWebAssemblyModule","compileWebAssemblyFromPath","u","createWorker","WorkerConstructor","workerPath","workerOptions","forwardedGlobals","WORKER_FORWARDED_GLOBALS","globalThis","existingWorkerData","workerData","options","__turbopack_globals__","regexJsUrl","chunkUrlOrPath","test"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime/hmr-runtime.ts"],"sourcesContent":["/// <reference path=\"./runtime-utils.ts\" />\n/// <reference path=\"./runtime-types.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n\ntype HotModuleFactoryFunction = ModuleFactoryFunction<\n  HotModule,\n  TurbopackBaseContext<HotModule>\n>\n\n/**\n * Shared HMR (Hot Module Replacement) implementation.\n *\n * This file contains the complete HMR implementation that's shared between\n * browser and Node.js runtimes. It manages module hot state, dependency\n * tracking, the module.hot API, and the full HMR update flow.\n */\n\n/**\n * The development module cache shared across the runtime.\n * Browser runtime declares this directly.\n * Node.js runtime assigns globalThis.__turbopack_module_cache__ to this.\n */\nlet devModuleCache: Record<ModuleId, any>\n\n/**\n * Module IDs that are instantiated as part of the runtime of a chunk.\n */\nlet runtimeModules: Set<ModuleId>\n\n/**\n * Maps module IDs to persisted data between executions of their hot module\n * implementation (`hot.data`).\n */\nconst moduleHotData: Map<ModuleId, HotData> = new Map()\n\n/**\n * Maps module instances to their hot module state.\n * Uses WeakMap so it works with both HotModule and ModuleWithDirection.\n */\nconst moduleHotState: WeakMap<any, HotState> = new WeakMap()\n\n/**\n * Modules that call `module.hot.invalidate()` (while being updated).\n */\nconst queuedInvalidatedModules: Set<ModuleId> = new Set()\n\nclass UpdateApplyError extends Error {\n  name = 'UpdateApplyError'\n\n  dependencyChain: ModuleId[]\n\n  constructor(message: string, dependencyChain: ModuleId[]) {\n    super(message)\n    this.dependencyChain = dependencyChain\n  }\n}\n\ntype ModuleEffect =\n  | {\n      type: 'unaccepted'\n      dependencyChain: ModuleId[]\n    }\n  | {\n      type: 'self-declined'\n      dependencyChain: ModuleId[]\n      moduleId: ModuleId\n    }\n  | {\n      type: 'accepted'\n      moduleId: ModuleId\n      outdatedModules: Set<ModuleId>\n    }\n\n/**\n * Records parent-child relationship when a module imports another.\n * Should be called during module instantiation.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction trackModuleImport(\n  parentModule: ModuleWithDirection,\n  childModuleId: ModuleId,\n  childModule: ModuleWithDirection | undefined\n): void {\n  // Record that parent imports child\n  if (parentModule.children.indexOf(childModuleId) === -1) {\n    parentModule.children.push(childModuleId)\n  }\n\n  // Record that child is imported by parent\n  if (childModule && childModule.parents.indexOf(parentModule.id) === -1) {\n    childModule.parents.push(parentModule.id)\n  }\n}\n\nfunction formatDependencyChain(dependencyChain: ModuleId[]): string {\n  return `Dependency chain: ${dependencyChain.join(' -> ')}`\n}\n\n/**\n * Walks the dependency tree to find all modules affected by a change.\n * Returns information about whether the update can be accepted and which\n * modules need to be invalidated.\n *\n * @param moduleId - The module that changed\n * @param autoAcceptRootModules - If true, root modules auto-accept updates without explicit module.hot.accept().\n *                           This is used for server-side HMR where pages auto-accept at the top level.\n */\nfunction getAffectedModuleEffects(\n  moduleId: ModuleId,\n  autoAcceptRootModules: boolean\n): ModuleEffect {\n  const outdatedModules: Set<ModuleId> = new Set()\n\n  type QueueItem = { moduleId?: ModuleId; dependencyChain: ModuleId[] }\n\n  const queue: QueueItem[] = [\n    {\n      moduleId,\n      dependencyChain: [],\n    },\n  ]\n\n  let nextItem\n  while ((nextItem = queue.shift())) {\n    const { moduleId, dependencyChain } = nextItem\n\n    if (moduleId != null) {\n      if (outdatedModules.has(moduleId)) {\n        // Avoid infinite loops caused by cycles between modules in the dependency chain.\n        continue\n      }\n\n      outdatedModules.add(moduleId)\n    }\n\n    // We've arrived at the runtime of the chunk, which means that nothing\n    // else above can accept this update.\n    if (moduleId === undefined) {\n      if (autoAcceptRootModules) {\n        return {\n          type: 'accepted',\n          moduleId,\n          outdatedModules,\n        }\n      }\n      return {\n        type: 'unaccepted',\n        dependencyChain,\n      }\n    }\n\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)!\n\n    if (\n      // The module is not in the cache. Since this is a \"modified\" update,\n      // it means that the module was never instantiated before.\n      !module || // The module accepted itself without invalidating globalThis.\n      // TODO is that right?\n      (hotState.selfAccepted && !hotState.selfInvalidated)\n    ) {\n      continue\n    }\n\n    if (hotState.selfDeclined) {\n      return {\n        type: 'self-declined',\n        dependencyChain,\n        moduleId,\n      }\n    }\n\n    if (runtimeModules.has(moduleId)) {\n      if (autoAcceptRootModules) {\n        continue\n      }\n      queue.push({\n        moduleId: undefined,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n      continue\n    }\n\n    for (const parentId of module.parents) {\n      const parent = devModuleCache[parentId]\n\n      if (!parent) {\n        // TODO(alexkirsz) Is this even possible?\n        continue\n      }\n\n      // TODO(alexkirsz) Dependencies: check accepted and declined\n      // dependencies here.\n\n      queue.push({\n        moduleId: parentId,\n        dependencyChain: [...dependencyChain, moduleId],\n      })\n    }\n\n    // If no parents and we're at a root module, auto-accept if configured\n    if (module.parents.length === 0 && autoAcceptRootModules) {\n      continue\n    }\n  }\n\n  return {\n    type: 'accepted',\n    moduleId,\n    outdatedModules,\n  }\n}\n\n/**\n * Computes all modules that need to be invalidated based on which modules changed.\n *\n * @param invalidated - The modules that have been invalidated\n * @param autoAcceptRootModules - If true, root modules auto-accept updates without explicit module.hot.accept()\n */\nfunction computedInvalidatedModules(\n  invalidated: Iterable<ModuleId>,\n  autoAcceptRootModules: boolean\n): Set<ModuleId> {\n  const outdatedModules = new Set<ModuleId>()\n\n  for (const moduleId of invalidated) {\n    const effect = getAffectedModuleEffects(moduleId, autoAcceptRootModules)\n\n    switch (effect.type) {\n      case 'unaccepted':\n        throw new UpdateApplyError(\n          `cannot apply update: unaccepted module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'self-declined':\n        throw new UpdateApplyError(\n          `cannot apply update: self-declined module. ${formatDependencyChain(\n            effect.dependencyChain\n          )}.`,\n          effect.dependencyChain\n        )\n      case 'accepted':\n        for (const outdatedModuleId of effect.outdatedModules) {\n          outdatedModules.add(outdatedModuleId)\n        }\n        break\n      // TODO(alexkirsz) Dependencies: handle dependencies effects.\n      default:\n        invariant(effect, (effect) => `Unknown effect type: ${effect?.type}`)\n    }\n  }\n\n  return outdatedModules\n}\n\n/**\n * Creates the module.hot API object and its internal state.\n * This provides the HMR API that user code calls (module.hot.accept(), etc.)\n */\n\nfunction createModuleHot(\n  moduleId: ModuleId,\n  hotData: HotData\n): { hot: Hot; hotState: HotState } {\n  const hotState: HotState = {\n    selfAccepted: false,\n    selfDeclined: false,\n    selfInvalidated: false,\n    disposeHandlers: [],\n  }\n\n  const hot: Hot = {\n    // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n    // decide whether to warn whenever an HMR-disposed module required other\n    // modules. We might want to remove it.\n    active: true,\n\n    data: hotData ?? {},\n\n    // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n    accept: (\n      modules?: string | string[] | AcceptErrorHandler,\n      _callback?: AcceptCallback,\n      _errorHandler?: AcceptErrorHandler\n    ) => {\n      if (modules === undefined) {\n        hotState.selfAccepted = true\n      } else if (typeof modules === 'function') {\n        hotState.selfAccepted = modules\n      } else {\n        throw new Error('unsupported `accept` signature')\n      }\n    },\n\n    decline: (dep) => {\n      if (dep === undefined) {\n        hotState.selfDeclined = true\n      } else {\n        throw new Error('unsupported `decline` signature')\n      }\n    },\n\n    dispose: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    addDisposeHandler: (callback) => {\n      hotState.disposeHandlers.push(callback)\n    },\n\n    removeDisposeHandler: (callback) => {\n      const idx = hotState.disposeHandlers.indexOf(callback)\n      if (idx >= 0) {\n        hotState.disposeHandlers.splice(idx, 1)\n      }\n    },\n\n    invalidate: () => {\n      hotState.selfInvalidated = true\n      queuedInvalidatedModules.add(moduleId)\n    },\n\n    // NOTE(alexkirsz) This is part of the management API, which we don't\n    // implement, but the Next.js React Refresh runtime uses this to decide\n    // whether to schedule an update.\n    status: () => 'idle',\n\n    // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n    addStatusHandler: (_handler) => {},\n    removeStatusHandler: (_handler) => {},\n\n    // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n    // want the webpack code paths to ever update (the turbopack paths handle\n    // this already).\n    check: () => Promise.resolve(null),\n  }\n\n  return { hot, hotState }\n}\n\n/**\n * Processes queued invalidated modules and adds them to the outdated modules set.\n * Modules that call module.hot.invalidate() are queued and processed here.\n *\n * @param outdatedModules - The current set of outdated modules\n * @param autoAcceptRootModules - If true, root modules auto-accept updates without explicit module.hot.accept()\n */\nfunction applyInvalidatedModules(\n  outdatedModules: Set<ModuleId>,\n  autoAcceptRootModules: boolean\n): Set<ModuleId> {\n  if (queuedInvalidatedModules.size > 0) {\n    computedInvalidatedModules(\n      queuedInvalidatedModules,\n      autoAcceptRootModules\n    ).forEach((moduleId) => {\n      outdatedModules.add(moduleId)\n    })\n\n    queuedInvalidatedModules.clear()\n  }\n\n  return outdatedModules\n}\n\n/**\n * Computes which outdated modules have self-accepted and can be hot reloaded.\n */\n\nfunction computeOutdatedSelfAcceptedModules(\n  outdatedModules: Iterable<ModuleId>\n): { moduleId: ModuleId; errorHandler: true | Function }[] {\n  const outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[] = []\n  for (const moduleId of outdatedModules) {\n    const module = devModuleCache[moduleId]\n    const hotState = moduleHotState.get(module)\n    if (module && hotState?.selfAccepted && !hotState.selfInvalidated) {\n      outdatedSelfAcceptedModules.push({\n        moduleId,\n        errorHandler: hotState.selfAccepted,\n      })\n    }\n  }\n  return outdatedSelfAcceptedModules\n}\n\n/**\n * Disposes of an instance of a module.\n * Runs hot.dispose handlers and manages persistent hot data.\n *\n * NOTE: mode = \"replace\" will not remove modules from devModuleCache.\n * This must be done in a separate step afterwards.\n */\nfunction disposeModule(moduleId: ModuleId, mode: 'clear' | 'replace') {\n  const module = devModuleCache[moduleId]\n  if (!module) {\n    return\n  }\n\n  const hotState = moduleHotState.get(module)\n  if (!hotState) {\n    return\n  }\n\n  const data: HotData = {}\n\n  // Run the `hot.dispose` handler, if any, passing in the persistent\n  // `hot.data` object.\n  for (const disposeHandler of hotState.disposeHandlers) {\n    disposeHandler(data)\n  }\n\n  // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n  // module is still importing other modules.\n  if (module.hot) {\n    module.hot.active = false\n  }\n\n  moduleHotState.delete(module)\n\n  // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n\n  // Remove the disposed module from its children's parent list.\n  // It will be added back once the module re-instantiates and imports its\n  // children again.\n  for (const childId of module.children) {\n    const child = devModuleCache[childId]\n    if (!child) {\n      continue\n    }\n\n    const idx = child.parents.indexOf(module.id)\n    if (idx >= 0) {\n      child.parents.splice(idx, 1)\n    }\n  }\n\n  switch (mode) {\n    case 'clear':\n      delete devModuleCache[module.id]\n      moduleHotData.delete(module.id)\n      break\n    case 'replace':\n      moduleHotData.set(module.id, data)\n      break\n    default:\n      invariant(mode, (mode) => `invalid mode: ${mode}`)\n  }\n}\n\n/**\n * Dispose phase: runs dispose handlers and cleans up outdated/disposed modules.\n * Returns the parent modules of outdated modules for use in the apply phase.\n */\n\nfunction disposePhase(\n  outdatedModules: Iterable<ModuleId>,\n  disposedModules: Iterable<ModuleId>\n): { outdatedModuleParents: Map<ModuleId, Array<ModuleId>> } {\n  for (const moduleId of outdatedModules) {\n    disposeModule(moduleId, 'replace')\n  }\n\n  for (const moduleId of disposedModules) {\n    disposeModule(moduleId, 'clear')\n  }\n\n  // Removing modules from the module cache is a separate step.\n  // We also want to keep track of previous parents of the outdated modules.\n  const outdatedModuleParents = new Map<ModuleId, Array<ModuleId>>()\n  for (const moduleId of outdatedModules) {\n    const oldModule = devModuleCache[moduleId]\n    outdatedModuleParents.set(moduleId, oldModule?.parents)\n    delete devModuleCache[moduleId]\n  }\n\n  // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n  // children.\n\n  return { outdatedModuleParents }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/**\n * Shared module instantiation logic.\n * This handles the full module instantiation flow for both browser and Node.js.\n * Only React Refresh hooks differ between platforms (passed as callback).\n */\nfunction instantiateModuleShared(\n  moduleId: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData,\n  moduleFactories: ModuleFactories,\n  devModuleCache: ModuleCache<HotModule>,\n  runtimeModules: Set<ModuleId>,\n  createModuleObjectFn: (id: ModuleId) => HotModule,\n  createContextFn: (module: HotModule, exports: Exports, refresh?: any) => any,\n  runModuleExecutionHooksFn: (\n    module: HotModule,\n    exec: (refresh: any) => void\n  ) => void\n): HotModule {\n  // 1. Factory validation (same in both browser and Node.js)\n  const id = moduleId as string\n  const moduleFactory = moduleFactories.get(id)\n  if (typeof moduleFactory !== 'function') {\n    throw new Error(\n      factoryNotAvailableMessage(moduleId, sourceType, sourceData) +\n        `\\nThis is often caused by a stale browser cache, misconfigured Cache-Control headers, or a service worker serving outdated responses.` +\n        `\\nTo fix this, make sure your Cache-Control headers allow revalidation of chunks and review your service worker configuration. ` +\n        `As an immediate workaround, try hard-reloading the page, clearing the browser cache, or unregistering any service workers.`\n    )\n  }\n\n  // 2. Hot API setup (same in both - works for browser, included for Node.js)\n  const hotData = moduleHotData.get(id)!\n  const { hot, hotState } = createModuleHot(id, hotData)\n\n  // 3. Parent assignment logic (same in both)\n  let parents: ModuleId[]\n  switch (sourceType) {\n    case SourceType.Runtime:\n      runtimeModules.add(id)\n      parents = []\n      break\n    case SourceType.Parent:\n      parents = [sourceData as ModuleId]\n      break\n    case SourceType.Update:\n      parents = (sourceData as ModuleId[]) || []\n      break\n    default:\n      throw new Error(`Unknown source type: ${sourceType}`)\n  }\n\n  // 4. Module creation (platform creates base module object)\n  const module = createModuleObjectFn(id)\n  const exports = module.exports\n  module.parents = parents\n  module.children = []\n  module.hot = hot\n\n  devModuleCache[id] = module\n  moduleHotState.set(module, hotState)\n\n  // 5. Module execution (React Refresh hooks are platform-specific)\n  try {\n    runModuleExecutionHooksFn(module, (refresh) => {\n      const context = createContextFn(module, exports, refresh)\n      moduleFactory.call(exports, context, module, exports)\n    })\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  // 6. ESM interop (same in both)\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\n/**\n * Analyzes update entries and chunks to determine which modules were added, modified, or deleted.\n * This is pure logic that doesn't depend on the runtime environment.\n */\nfunction computeChangedModules(\n  entries: Record<ModuleId, EcmascriptModuleEntry>,\n  updates: Record<ChunkPath, EcmascriptMergedChunkUpdate>,\n  chunkModulesMap?: Map<ChunkPath, Set<ModuleId>>\n): {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n  deleted: Set<ModuleId>\n  chunksAdded: Map<ChunkPath, Set<ModuleId>>\n  chunksDeleted: Map<ChunkPath, Set<ModuleId>>\n} {\n  const chunksAdded = new Map()\n  const chunksDeleted = new Map()\n  const added: Map<ModuleId, EcmascriptModuleEntry> = new Map()\n  const modified = new Map()\n  const deleted: Set<ModuleId> = new Set()\n\n  for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates) as Array<\n    [ChunkPath, EcmascriptMergedChunkUpdate]\n  >) {\n    switch (mergedChunkUpdate.type) {\n      case 'added': {\n        const updateAdded = new Set(mergedChunkUpdate.modules)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        break\n      }\n      case 'deleted': {\n        const updateDeleted = chunkModulesMap\n          ? new Set(chunkModulesMap.get(chunkPath))\n          : new Set<ModuleId>()\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      case 'partial': {\n        const updateAdded = new Set(mergedChunkUpdate.added)\n        const updateDeleted = new Set(mergedChunkUpdate.deleted)\n        for (const moduleId of updateAdded) {\n          added.set(moduleId, entries[moduleId])\n        }\n        for (const moduleId of updateDeleted) {\n          deleted.add(moduleId)\n        }\n        chunksAdded.set(chunkPath, updateAdded)\n        chunksDeleted.set(chunkPath, updateDeleted)\n        break\n      }\n      default:\n        throw new Error('Unknown merged chunk update type')\n    }\n  }\n\n  // If a module was added from one chunk and deleted from another in the same update,\n  // consider it to be modified, as it means the module was moved from one chunk to another\n  // AND has new code in a single update.\n  for (const moduleId of added.keys()) {\n    if (deleted.has(moduleId)) {\n      added.delete(moduleId)\n      deleted.delete(moduleId)\n    }\n  }\n\n  for (const [moduleId, entry] of Object.entries(entries)) {\n    // Modules that haven't been added to any chunk but have new code are considered\n    // to be modified.\n    // This needs to be under the previous loop, as we need it to get rid of modules\n    // that were added and deleted in the same update.\n    if (!added.has(moduleId)) {\n      modified.set(moduleId, entry)\n    }\n  }\n\n  return { added, deleted, modified, chunksAdded, chunksDeleted }\n}\n\n/**\n * Compiles new module code and walks the dependency tree to find all outdated modules.\n * Uses the evalModuleEntry function to compile code (platform-specific).\n *\n * @param added - Map of added modules\n * @param modified - Map of modified modules\n * @param evalModuleEntry - Function to compile module code\n * @param autoAcceptRootModules - If true, root modules auto-accept updates without explicit module.hot.accept()\n */\nfunction computeOutdatedModules(\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>,\n  modified: Map<ModuleId, EcmascriptModuleEntry>,\n  evalModuleEntry: (entry: EcmascriptModuleEntry) => HotModuleFactoryFunction,\n  autoAcceptRootModules: boolean\n): {\n  outdatedModules: Set<ModuleId>\n  newModuleFactories: Map<ModuleId, HotModuleFactoryFunction>\n} {\n  const newModuleFactories = new Map<ModuleId, HotModuleFactoryFunction>()\n\n  // Compile added modules\n  for (const [moduleId, entry] of added) {\n    if (entry != null) {\n      newModuleFactories.set(moduleId, evalModuleEntry(entry))\n    }\n  }\n\n  // Walk dependency tree to find all modules affected by modifications\n  const outdatedModules = computedInvalidatedModules(\n    modified.keys(),\n    autoAcceptRootModules\n  )\n\n  // Compile modified modules\n  for (const [moduleId, entry] of modified) {\n    newModuleFactories.set(moduleId, evalModuleEntry(entry))\n  }\n\n  return { outdatedModules, newModuleFactories }\n}\n\n/**\n * Updates module factories and re-instantiates self-accepted modules.\n * Uses the instantiateModule function (platform-specific via callback).\n */\nfunction applyPhase(\n  outdatedSelfAcceptedModules: {\n    moduleId: ModuleId\n    errorHandler: true | Function\n  }[],\n  newModuleFactories: Map<ModuleId, HotModuleFactoryFunction>,\n  outdatedModuleParents: Map<ModuleId, Array<ModuleId>>,\n  moduleFactories: ModuleFactories,\n  devModuleCache: ModuleCache<HotModule>,\n  instantiateModuleFn: (\n    moduleId: ModuleId,\n    sourceType: SourceType,\n    sourceData: SourceData\n  ) => HotModule,\n  applyModuleFactoryNameFn: (factory: HotModuleFactoryFunction) => void,\n  reportError: (err: any) => void\n) {\n  // Update module factories\n  for (const [moduleId, factory] of newModuleFactories.entries()) {\n    applyModuleFactoryNameFn(factory)\n    moduleFactories.set(moduleId, factory)\n  }\n\n  // TODO(alexkirsz) Run new runtime entries here.\n\n  // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n\n  // Re-instantiate all outdated self-accepted modules\n  for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules) {\n    try {\n      instantiateModuleFn(\n        moduleId,\n        SourceType.Update,\n        outdatedModuleParents.get(moduleId)\n      )\n    } catch (err) {\n      if (typeof errorHandler === 'function') {\n        try {\n          errorHandler(err, { moduleId, module: devModuleCache[moduleId] })\n        } catch (err2) {\n          reportError(err2)\n          reportError(err)\n        }\n      } else {\n        reportError(err)\n      }\n    }\n  }\n}\n\n/**\n * Internal implementation that orchestrates the full HMR update flow:\n * invalidation, disposal, and application of new modules.\n *\n * @param autoAcceptRootModules - If true, root modules auto-accept updates without explicit module.hot.accept()\n */\nfunction applyInternal(\n  outdatedModules: Set<ModuleId>,\n  disposedModules: Iterable<ModuleId>,\n  newModuleFactories: Map<ModuleId, HotModuleFactoryFunction>,\n  moduleFactories: ModuleFactories,\n  devModuleCache: ModuleCache<HotModule>,\n  instantiateModuleFn: (\n    moduleId: ModuleId,\n    sourceType: SourceType,\n    sourceData: SourceData\n  ) => HotModule,\n  applyModuleFactoryNameFn: (factory: HotModuleFactoryFunction) => void,\n  autoAcceptRootModules: boolean\n) {\n  outdatedModules = applyInvalidatedModules(\n    outdatedModules,\n    autoAcceptRootModules\n  )\n\n  // Find self-accepted modules to re-instantiate\n  const outdatedSelfAcceptedModules =\n    computeOutdatedSelfAcceptedModules(outdatedModules)\n\n  // Run dispose handlers, save hot.data, clear caches\n  const { outdatedModuleParents } = disposePhase(\n    outdatedModules,\n    disposedModules\n  )\n\n  let error: any\n\n  function reportError(err: any) {\n    if (!error) error = err // Keep first error\n  }\n\n  applyPhase(\n    outdatedSelfAcceptedModules,\n    newModuleFactories,\n    outdatedModuleParents,\n    moduleFactories,\n    devModuleCache,\n    instantiateModuleFn,\n    applyModuleFactoryNameFn,\n    reportError\n  )\n\n  if (error) {\n    throw error\n  }\n\n  // Recursively apply any queued invalidations from new module execution\n  if (queuedInvalidatedModules.size > 0) {\n    applyInternal(\n      new Set(),\n      [],\n      new Map(),\n      moduleFactories,\n      devModuleCache,\n      instantiateModuleFn,\n      applyModuleFactoryNameFn,\n      autoAcceptRootModules\n    )\n  }\n}\n\n/**\n * Main entry point for applying an ECMAScript merged update.\n * This is called by both browser and Node.js runtimes with platform-specific callbacks.\n *\n * @param options.autoAcceptRootModules - If true, root modules auto-accept updates without explicit\n *                                   module.hot.accept(). Used for server-side HMR where pages\n *                                   auto-accept at the top level.\n */\nfunction applyEcmascriptMergedUpdateShared(options: {\n  added: Map<ModuleId, EcmascriptModuleEntry | undefined>\n  modified: Map<ModuleId, EcmascriptModuleEntry>\n  disposedModules: Iterable<ModuleId>\n  evalModuleEntry: (entry: EcmascriptModuleEntry) => HotModuleFactoryFunction\n  instantiateModule: (\n    moduleId: ModuleId,\n    sourceType: SourceType,\n    sourceData: SourceData\n  ) => HotModule\n  applyModuleFactoryName: (factory: HotModuleFactoryFunction) => void\n  moduleFactories: ModuleFactories\n  devModuleCache: ModuleCache<HotModule>\n  autoAcceptRootModules: boolean\n}) {\n  const {\n    added,\n    modified,\n    disposedModules,\n    evalModuleEntry,\n    instantiateModule,\n    applyModuleFactoryName,\n    moduleFactories,\n    devModuleCache,\n    autoAcceptRootModules,\n  } = options\n\n  const { outdatedModules, newModuleFactories } = computeOutdatedModules(\n    added,\n    modified,\n    evalModuleEntry,\n    autoAcceptRootModules\n  )\n\n  applyInternal(\n    outdatedModules,\n    disposedModules,\n    newModuleFactories,\n    moduleFactories,\n    devModuleCache,\n    instantiateModule,\n    applyModuleFactoryName,\n    autoAcceptRootModules\n  )\n}\n"],"names":["devModuleCache","runtimeModules","moduleHotData","Map","moduleHotState","WeakMap","queuedInvalidatedModules","Set","UpdateApplyError","Error","name","dependencyChain","message","trackModuleImport","parentModule","childModuleId","childModule","children","indexOf","push","parents","id","formatDependencyChain","join","getAffectedModuleEffects","moduleId","autoAcceptRootModules","outdatedModules","queue","nextItem","shift","has","add","undefined","type","module","hotState","get","selfAccepted","selfInvalidated","selfDeclined","parentId","parent","length","computedInvalidatedModules","invalidated","effect","outdatedModuleId","invariant","createModuleHot","hotData","disposeHandlers","hot","active","data","accept","modules","_callback","_errorHandler","decline","dep","dispose","callback","addDisposeHandler","removeDisposeHandler","idx","splice","invalidate","status","addStatusHandler","_handler","removeStatusHandler","check","Promise","resolve","applyInvalidatedModules","size","forEach","clear","computeOutdatedSelfAcceptedModules","outdatedSelfAcceptedModules","errorHandler","disposeModule","mode","disposeHandler","delete","childId","child","set","disposePhase","disposedModules","outdatedModuleParents","oldModule","instantiateModuleShared","sourceType","sourceData","moduleFactories","createModuleObjectFn","createContextFn","runModuleExecutionHooksFn","moduleFactory","factoryNotAvailableMessage","SourceType","Runtime","Parent","Update","exports","refresh","context","call","error","namespaceObject","interopEsm","computeChangedModules","entries","updates","chunkModulesMap","chunksAdded","chunksDeleted","added","modified","deleted","chunkPath","mergedChunkUpdate","Object","updateAdded","updateDeleted","keys","entry","computeOutdatedModules","evalModuleEntry","newModuleFactories","applyPhase","instantiateModuleFn","applyModuleFactoryNameFn","reportError","factory","err","err2","applyInternal","applyEcmascriptMergedUpdateShared","options","instantiateModule","applyModuleFactoryName"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1382, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/nodejs/runtime/dev-base.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-base.ts\" />\n/// <reference path=\"../../shared/runtime/dev-extensions.ts\" />\n/// <reference path=\"../../shared/runtime/hmr-runtime.ts\" />\n\n/**\n * Development Node.js runtime.\n * Uses HotModule and shared HMR logic for hot module replacement support.\n */\n\n// Cast the module cache to HotModule for development mode\n// (hmr-runtime.ts declares devModuleCache as `let` variable expecting assignment)\n// This is safe because HotModule extends Module\ndevModuleCache = moduleCache as ModuleCache<HotModule>\n\n// this is read in runtime-utils.ts so it creates a module with direction for hmr\ncreateModuleWithDirectionFlag = true\n\nif (!globalThis.__turbopack_runtime_modules__) {\n  globalThis.__turbopack_runtime_modules__ = new Set()\n}\nruntimeModules = globalThis.__turbopack_runtime_modules__\n\ninterface TurbopackNodeDevBuildContext extends TurbopackBaseContext<HotModule> {\n  R: ResolvePathFromModule\n  x: ExternalRequire\n  y: ExternalImport\n  C: typeof clearChunkCache\n}\n\nconst nodeDevContextPrototype =\n  Context.prototype as TurbopackNodeDevBuildContext\n\nnodeDevContextPrototype.q = exportUrl\nnodeDevContextPrototype.M = moduleFactories\nnodeDevContextPrototype.c = devModuleCache\nnodeDevContextPrototype.R = resolvePathFromModule\nnodeDevContextPrototype.b = createWorker\nnodeDevContextPrototype.C = clearChunkCache\n\n/**\n * Instantiates a module in development mode using shared HMR logic.\n */\nfunction instantiateModule(\n  id: ModuleId,\n  sourceType: SourceType,\n  sourceData: SourceData\n): HotModule {\n  // Node.js: creates base module object (hot API added by shared code)\n  const createModuleObjectFn = (moduleId: ModuleId) => {\n    return createModuleWithDirection(moduleId) as HotModule\n  }\n\n  // Node.js: creates Context (no refresh parameter)\n  const createContext = (\n    module: HotModule,\n    exports: Exports,\n    _refresh?: any\n  ) => {\n    return new (Context as any as ContextConstructor<HotModule>)(\n      module,\n      exports\n    )\n  }\n\n  // Node.js: no hooks wrapper, just execute directly\n  const runWithHooks = (module: HotModule, exec: (refresh: any) => void) => {\n    exec(undefined) // no refresh context\n  }\n\n  // Use shared instantiation logic (includes hot API setup)\n  const newModule = instantiateModuleShared(\n    id,\n    sourceType,\n    sourceData,\n    moduleFactories,\n    devModuleCache,\n    runtimeModules,\n    createModuleObjectFn,\n    createContext,\n    runWithHooks\n  )\n\n  // Node.js-specific: mark module as loaded\n  ;(newModule as any).loaded = true\n\n  return newModule\n}\n\n/**\n * Instantiates a runtime module in development mode.\n */\nfunction instantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): HotModule {\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\n */\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\nfunction getOrInstantiateRuntimeModule(\n  chunkPath: ChunkPath,\n  moduleId: ModuleId\n): HotModule {\n  const module = devModuleCache[moduleId]\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  return instantiateRuntimeModule(chunkPath, moduleId)\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n * Also tracks parent-child relationships for HMR dependency tracking.\n */\n// @ts-ignore\nfunction getOrInstantiateModuleFromParent(\n  id: ModuleId,\n  sourceModule: HotModule\n): HotModule {\n  // Track parent-child relationship\n  trackModuleImport(sourceModule, id, devModuleCache[id])\n\n  const module = devModuleCache[id]\n\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n\n    return module\n  }\n\n  const newModule = instantiateModule(id, SourceType.Parent, sourceModule.id)\n\n  // Track again after instantiation to ensure the relationship is recorded\n  trackModuleImport(sourceModule, id, newModule)\n\n  return newModule\n}\n\nmodule.exports = (sourcePath: ChunkPath) => ({\n  m: (id: ModuleId) => getOrInstantiateRuntimeModule(sourcePath, id),\n  c: (chunkData: ChunkData) => loadRuntimeChunk(sourcePath, chunkData),\n})\n"],"names":["devModuleCache","moduleCache","createModuleWithDirectionFlag","globalThis","__turbopack_runtime_modules__","Set","runtimeModules","nodeDevContextPrototype","Context","prototype","q","exportUrl","M","moduleFactories","c","R","resolvePathFromModule","b","createWorker","C","clearChunkCache","instantiateModule","id","sourceType","sourceData","createModuleObjectFn","moduleId","createModuleWithDirection","createContext","module1","exports","_refresh","runWithHooks","exec","undefined","newModule","instantiateModuleShared","loaded","instantiateRuntimeModule","chunkPath","SourceType","Runtime","getOrInstantiateRuntimeModule","error","getOrInstantiateModuleFromParent","sourceModule","trackModuleImport","Parent","module","sourcePath","m","chunkData","loadRuntimeChunk"],"mappings":"AAAA,oDAAoD,GAEpD,0CAA0C;AAC1C,+DAA+D;AAC/D,4DAA4D;AAE5D;;;CAGC,GAED,0DAA0D;AAC1D,kFAAkF;AAClF,gDAAgD;AAChDA,iBAAiBC;AAEjB,iFAAiF;AACjFC,gCAAgC;AAEhC,IAAI,CAACC,WAAWC,6BAA6B,EAAE;IAC7CD,WAAWC,6BAA6B,GAAG,IAAIC;AACjD;AACAC,iBAAiBH,WAAWC,6BAA6B;AASzD,MAAMG,0BACJC,QAAQC,SAAS;AAEnBF,wBAAwBG,CAAC,GAAGC;AAC5BJ,wBAAwBK,CAAC,GAAGC;AAC5BN,wBAAwBO,CAAC,GAAGd;AAC5BO,wBAAwBQ,CAAC,GAAGC;AAC5BT,wBAAwBU,CAAC,GAAGC;AAC5BX,wBAAwBY,CAAC,GAAGC;AAE5B;;CAEC,GACD,SAASC,kBACPC,EAAY,EACZC,UAAsB,EACtBC,UAAsB;IAEtB,qEAAqE;IACrE,MAAMC,uBAAuB,CAACC;QAC5B,OAAOC,0BAA0BD;IACnC;IAEA,kDAAkD;IAClD,MAAME,gBAAgB,CACpBC,SACAC,SACAC;QAEA,OAAO,IAAKvB,QACVqB,SACAC;IAEJ;IAEA,mDAAmD;IACnD,MAAME,eAAe,CAACH,SAAmBI;QACvCA,KAAKC,YAAW,qBAAqB;IACvC;IAEA,0DAA0D;IAC1D,MAAMC,YAAYC,wBAChBd,IACAC,YACAC,YACAX,iBACAb,gBACAM,gBACAmB,sBACAG,eACAI;IAIAG,UAAkBE,MAAM,GAAG;IAE7B,OAAOF;AACT;AAEA;;CAEC,GACD,SAASG,yBACPC,SAAoB,EACpBb,QAAkB;IAElB,OAAOL,kBAAkBK,UAAUc,WAAWC,OAAO,EAAEF;AACzD;AAEA;;CAEC,GACD,oFAAoF;AACpF,SAASG,8BACPH,SAAoB,EACpBb,QAAkB;IAElB,MAAMG,UAAS7B,cAAc,CAAC0B,SAAS;IAEvC,IAAIG,SAAQ;QACV,IAAIA,QAAOc,KAAK,EAAE;YAChB,MAAMd,QAAOc,KAAK;QACpB;QACA,OAAOd;IACT;IAEA,OAAOS,yBAAyBC,WAAWb;AAC7C;AAEA;;;CAGC,GACD,aAAa;AACb,SAASkB,iCACPtB,EAAY,EACZuB,YAAuB;IAEvB,kCAAkC;IAClCC,kBAAkBD,cAAcvB,IAAItB,cAAc,CAACsB,GAAG;IAEtD,MAAMO,UAAS7B,cAAc,CAACsB,GAAG;IAEjC,IAAIO,SAAQ;QACV,IAAIA,QAAOc,KAAK,EAAE;YAChB,MAAMd,QAAOc,KAAK;QACpB;QAEA,OAAOd;IACT;IAEA,MAAMM,YAAYd,kBAAkBC,IAAIkB,WAAWO,MAAM,EAAEF,aAAavB,EAAE;IAE1E,yEAAyE;IACzEwB,kBAAkBD,cAAcvB,IAAIa;IAEpC,OAAOA;AACT;AAEAa,OAAOlB,OAAO,GAAG,CAACmB,aAA0B,CAAC;QAC3CC,GAAG,CAAC5B,KAAiBoB,8BAA8BO,YAAY3B;QAC/DR,GAAG,CAACqC,YAAyBC,iBAAiBH,YAAYE;IAC5D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1466, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/nodejs/dev/hmr-client.ts"],"sourcesContent":["/// <reference path=\"../../shared/runtime/dev-protocol.d.ts\" />\n/// <reference path=\"../../shared/runtime/hmr-runtime.ts\" />\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\ntype NodeJsHmrPayload = {\n  resource: {\n    path: string\n    headers?: Record<string, string>\n  }\n  issues: Issue[]\n  type: 'partial'\n  instruction: EcmascriptMergedUpdate\n}\n\nlet serverHmrUpdateHandler: ((msg: NodeJsHmrPayload) => void) | null = null\n\nfunction initializeServerHmr(\n  moduleFactories: ModuleFactories,\n  devModuleCache: ModuleCache<HotModule>\n): void {\n  if (serverHmrUpdateHandler != null) {\n    throw new Error('[Server HMR] Server HMR client is already initialized')\n  }\n\n  // Register the update handler for the server runtime\n  serverHmrUpdateHandler = (msg: NodeJsHmrPayload) => {\n    handleNodejsUpdate(msg, moduleFactories, devModuleCache)\n  }\n}\n\n/**\n * Emits an HMR message to the registered update handler.\n * Node uses a simpler listener pattern than the browser's websocket connection.\n *\n * Note: This is only called via __turbopack_server_hmr_apply__ which ensures\n * the handler is initialized first via ensureHmrClientInitialized().\n */\nfunction emitMessage(msg: { type: string; data: any }): boolean {\n  if (serverHmrUpdateHandler == null) {\n    console.warn(\n      '[Server HMR] No update handler registered to receive message:',\n      msg\n    )\n    return false\n  }\n\n  try {\n    serverHmrUpdateHandler(msg.data)\n    return true\n  } catch (err) {\n    console.error('[Server HMR] Listener error:', err)\n    return false\n  }\n}\n\n/**\n * Handles server message updates and applies them to the Node.js runtime.\n * Uses shared HMR update logic from hmr-runtime.ts.\n */\nfunction handleNodejsUpdate(\n  msg: NodeJsHmrPayload,\n  moduleFactories: ModuleFactories,\n  devModuleCache: ModuleCache<HotModule>\n): void {\n  if (msg.type !== 'partial') {\n    return\n  }\n\n  const instruction = msg.instruction\n  if (instruction.type !== 'EcmascriptMergedUpdate') {\n    return\n  }\n\n  try {\n    const { entries = {}, chunks = {} } = instruction\n\n    // Node.js eval function (no source maps)\n    const evalModuleEntry = (entry: EcmascriptModuleEntry) => {\n      // eslint-disable-next-line no-eval\n      return (0, eval)(entry.code)\n    }\n\n    const { added, modified } = computeChangedModules(\n      entries,\n      chunks,\n      undefined // no chunkModulesMap for Node.js\n    )\n\n    // Use shared HMR update implementation\n    applyEcmascriptMergedUpdateShared({\n      added,\n      modified,\n      disposedModules: [], // no disposedModules for Node.js (no chunk management)\n      evalModuleEntry,\n      instantiateModule,\n      applyModuleFactoryName: () => {}, // Node doesn't use this\n      moduleFactories,\n      devModuleCache,\n      autoAcceptRootModules: true,\n    })\n  } catch (e) {\n    console.error('[Server HMR] Update failed, full reload needed:', e)\n    throw e\n  }\n}\n"],"names":["serverHmrUpdateHandler","initializeServerHmr","moduleFactories","devModuleCache","Error","msg","handleNodejsUpdate","emitMessage","console","warn","data","err","error","type","instruction","entries","chunks","evalModuleEntry","entry","eval","code","added","modified","computeChangedModules","undefined","applyEcmascriptMergedUpdateShared","disposedModules","instantiateModule","applyModuleFactoryName","autoAcceptRootModules","e"],"mappings":"AAAA,+DAA+D;AAC/D,4DAA4D;AAE5D,oDAAoD,GAYpD,IAAIA,yBAAmE;AAEvE,SAASC,oBACPC,eAAgC,EAChCC,cAAsC;IAEtC,IAAIH,0BAA0B,MAAM;QAClC,MAAM,IAAII,MAAM;IAClB;IAEA,qDAAqD;IACrDJ,yBAAyB,CAACK;QACxBC,mBAAmBD,KAAKH,iBAAiBC;IAC3C;AACF;AAEA;;;;;;CAMC,GACD,SAASI,YAAYF,GAAgC;IACnD,IAAIL,0BAA0B,MAAM;QAClCQ,QAAQC,IAAI,CACV,iEACAJ;QAEF,OAAO;IACT;IAEA,IAAI;QACFL,uBAAuBK,IAAIK,IAAI;QAC/B,OAAO;IACT,EAAE,OAAOC,KAAK;QACZH,QAAQI,KAAK,CAAC,gCAAgCD;QAC9C,OAAO;IACT;AACF;AAEA;;;CAGC,GACD,SAASL,mBACPD,GAAqB,EACrBH,eAAgC,EAChCC,cAAsC;IAEtC,IAAIE,IAAIQ,IAAI,KAAK,WAAW;QAC1B;IACF;IAEA,MAAMC,cAAcT,IAAIS,WAAW;IACnC,IAAIA,YAAYD,IAAI,KAAK,0BAA0B;QACjD;IACF;IAEA,IAAI;QACF,MAAM,EAAEE,UAAU,CAAC,CAAC,EAAEC,SAAS,CAAC,CAAC,EAAE,GAAGF;QAEtC,yCAAyC;QACzC,MAAMG,kBAAkB,CAACC;YACvB,mCAAmC;YACnC,OAAO,CAAC,GAAGC,IAAI,EAAED,MAAME,IAAI;QAC7B;QAEA,MAAM,EAAEC,KAAK,EAAEC,QAAQ,EAAE,GAAGC,sBAC1BR,SACAC,QACAQ,UAAU,iCAAiC;;QAG7C,uCAAuC;QACvCC,kCAAkC;YAChCJ;YACAC;YACAI,iBAAiB,EAAE;YACnBT;YACAU;YACAC,wBAAwB,KAAO;YAC/B1B;YACAC;YACA0B,uBAAuB;QACzB;IACF,EAAE,OAAOC,GAAG;QACVtB,QAAQI,KAAK,CAAC,mDAAmDkB;QACjE,MAAMA;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 1534, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/nodejs/dev/dev-nodejs.ts"],"sourcesContent":["/// <reference path=\"../../shared/runtime/dev-protocol.d.ts\" />\n/// <reference path=\"./hmr-client.ts\" />\n\n/**\n * Note: hmr-runtime.ts is embedded before this file, so its functions\n * (initializeServerHmr, emitMessage) are available in the same scope.\n */\n\n// Initialize server HMR client (connects to shared HMR infrastructure)\nlet hmrClientInitialized = false\nfunction ensureHmrClientInitialized() {\n  if (hmrClientInitialized) return\n  hmrClientInitialized = true\n\n  // initializeServerHmr is from hmr-client.ts (embedded before this file)\n  // moduleFactories is from dev-runtime.ts\n  // devModuleCache is the HotModule-typed cache from dev-runtime.ts\n  initializeServerHmr(moduleFactories, devModuleCache)\n}\n\nfunction __turbopack_server_hmr_apply__(update: NodeJsHmrPayload): boolean {\n  try {\n    ensureHmrClientInitialized()\n\n    // emitMessage returns false if any listener failed to apply the update\n    return emitMessage({\n      type: 'turbopack-message',\n      data: update,\n    })\n  } catch (err) {\n    console.error('[Server HMR] Failed to apply update:', err)\n    return false\n  }\n}\n\nglobalThis.__turbopack_server_hmr_apply__ = __turbopack_server_hmr_apply__\n"],"names":["hmrClientInitialized","ensureHmrClientInitialized","initializeServerHmr","moduleFactories","devModuleCache","__turbopack_server_hmr_apply__","update","emitMessage","type","data","err","console","error","globalThis"],"mappings":"AAAA,+DAA+D;AAC/D,wCAAwC;AAExC;;;CAGC,GAED,uEAAuE;AACvE,IAAIA,uBAAuB;AAC3B,SAASC;IACP,IAAID,sBAAsB;IAC1BA,uBAAuB;IAEvB,wEAAwE;IACxE,yCAAyC;IACzC,kEAAkE;IAClEE,oBAAoBC,iBAAiBC;AACvC;AAEA,SAASC,+BAA+BC,MAAwB;IAC9D,IAAI;QACFL;QAEA,uEAAuE;QACvE,OAAOM,YAAY;YACjBC,MAAM;YACNC,MAAMH;QACR;IACF,EAAE,OAAOI,KAAK;QACZC,QAAQC,KAAK,CAAC,wCAAwCF;QACtD,OAAO;IACT;AACF;AAEAG,WAAWR,8BAA8B,GAAGA","ignoreList":[0]}}]
}